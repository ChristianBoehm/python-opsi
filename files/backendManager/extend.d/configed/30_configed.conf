# -*- coding: utf-8 -*-

def _getProductStates_hash(self, objectIds=[], options={}, productType=None):
	#based on productOnClients 
	if not productType: productType = None
	result = {}
	
	productHasPriority = {}
	priorityClasses = {}
	
	for product in self.product_getObjects():
		prio = product.priority
		if not prio:
			prio = 0
		productHasPriority[product.id]= prio
		
		if not priorityClasses.has_key(prio):
			priorityClasses[prio] = []
		priorityClasses[prio] .append(product.id)
	
	#self.backend_setOptions({"addProductOnClientDefaults": True})
	productOnClients = self.productOnClient_getObjects(clientId = objectIds, productType = productType)
	
	
	for productOnClient in productOnClients:
		if not result.has_key(productOnClient.clientId):
			result[productOnClient.clientId] = []
		lastStateChange = productOnClient.modificationTime or u''
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', lastStateChange)
		if match:
			lastStateChange = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
			
		actionSequence = productHasPriority[productOnClient.productId];
		if not actionSequence:
			actionSequence = 0
			
		result[productOnClient.clientId].append({
			u"lastStateChange":     lastStateChange,
			u"productVersion":      productOnClient.productVersion or u'',
			u"packageVersion":      productOnClient.packageVersion or u'',
			u"targetConfiguration": productOnClient.targetConfiguration or u'',
			u"lastAction":          productOnClient.lastAction or u'',
			u"installationStatus":  productOnClient.installationStatus,
			u"actionRequest":       productOnClient.actionRequest,
			u"actionProgress":      productOnClient.actionProgress or u'',
			u"actionResult":        productOnClient.actionResult or u'',
			u"productId":           productOnClient.productId,
			u"productPriority":	productHasPriority[productOnClient.productId],
			u"actionSequence": 	actionSequence
			#u"actionSequence": 	productOnClient.actionSequence
		})
	return result

def getLocalBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'LocalbootProduct')

def getNetBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'NetbootProduct')

def getProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options)


def _getProducts_hash(self, depotIds=[]):
	result = {}
	for depotId in depotIds:
		result[depotId] = {}
	
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotIds):
		if not result.has_key(productOnDepot.depotId):
			result[productOnDepot.depotId] = {}
		product = products.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion)
		if not product:
			raise BackendMissingDataError(u"Product with id '%s', productVersion '%s', packageVersion '%s' not found" \
				% (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion))
		result[productOnDepot.depotId][productOnDepot.productId] = self._productToHash(product)
	return result
	

def _getProductsInDepot(self, depotId=None):
	depotIds = self.host_getIdents(type = 'OpsiDepotserver', returnType = 'unicode')
	products = self.product_getObjects()
	
	if depotId in depotIds:
		filteredProducts = []
		productsByIdAndVersion = {}
		for product in products:
			if not productsByIdAndVersion.has_key(product.id):
				productsByIdAndVersion[product.id] = {}
			if not productsByIdAndVersion[product.id].has_key(product.productVersion):
				productsByIdAndVersion[product.id][product.productVersion] = {}
			productsByIdAndVersion[product.id][product.productVersion][product.packageVersion] = product
			
		for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
			product = productsByIdAndVersion.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion)
			if product:
				filteredProducts.append(product)
		products = filteredProducts
		
	return products



def getProductOrdering_list(self, depotId=None):
	
	products = self._getProductsInDepot(depotId)
	
	#build priority classes and indices
	priorityClasses = {}
	productIndexInClass = {}
	productById = {}
	for product in products:
		productById[product.id] = product
		prio = str(0)
		if product.priority:
			prio = str(product.priority)
		if not priorityClasses.has_key(prio):
			priorityClasses[prio] = []
		priorityClasses[prio] .append(product.id)
		productIndexInClass[product.id] = len(priorityClasses[prio])-1
	
	#return priorityClasses
	# test return (priorityClasses["0"][productIndexInClass[u"preloginloader"]] ) == u"preloginloader"  
	# get requirements
	setupRequirements = []
	
	result = u""
	dependencies = self.getProductDependencies_listOfHashes(depotId)
	
	for dependency in dependencies:
		if dependency[u"action"] == u"setup":
			if dependency[u"requirementType"] ==u"before":
				if (dependency[u"requiredInstallationStatus"] == u"installed") or (dependency[u"requiredAction"] == u"setup"):  
					setupRequirements.append([dependency[u"requiredProductId"], dependency[u"productId"]])
				
			elif dependency[u"requirementType"] ==u"after":
				if (dependency[u"requiredInstallationStatus"] == u"installed") or (dependency[u"requiredAction"] == u"setup"):  
					setupRequirements.append(dependency[u"productId"], [dependency[u"requiredProductId"]])

	requirementsByClasses = {}
	
	for requ in setupRequirements:
		prod1 = requ[0]
		prod2 = requ[1]
		prio1 = productById[prod1].priority
		if not prio1:
			prio1 = 0
		prio2 = productById[prod2].priority
		if not prio2:
			prio2 = 0
			
		if prio1 > prio2:
			pass # sorted by priorities
		elif prio1 < prio2:
			pass
			#error # not fulfillable
		else:
			prioclass = str(prio1)
			if not requirementsByClasses.has_key(prioclass):
				requirementsByClasses[prioclass] = []
				
			requirementsByClasses[prioclass].append([prod1,prod2]) 
			
	return [productById[u"testdependency1"], productById[u"testdependency2"], requirementsByClasses]
	


def getProductInfos_hash(self, depotId=None):
	products = self._getProductsInDepot(depotId)
	
	result = {}
	for product in products:
		result[product.id] = {
			'name':            product.name,
			'description':     product.description,
			'advice':          product.advice,
			'priority':        product.priority,
			'productVersion':  product.productVersion,
			'packageVersion':  product.packageVersion,
			'actions':         [ u'none' ]
		}
		if product.setupScript:     result[product.id]['actions'].append(u'setup')
		if product.uninstallScript: result[product.id]['actions'].append(u'uninstall')
		if product.updateScript:    result[product.id]['actions'].append(u'update')
		if product.alwaysScript:    result[product.id]['actions'].append(u'always')
		if product.onceScript:      result[product.id]['actions'].append(u'once')
		if product.customScript:    result[product.id]['actions'].append(u'custom')
	return result

	
	
	
	
	
	
	
	
	
	
	
	





