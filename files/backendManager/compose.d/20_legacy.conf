# -*- coding: utf-8 -*-

def _hashValuesNoneToEmptyString(self, hash):
	for (key, value) in hash.items():
		if value is None:
			hash[key] = ''
	return hash

# OK
def createOpsiBase(self):
	return self.base_create()

# OK
def getPossibleMethods_listOfHashes(self):
	return self.getInterface()

# OK
def authenticated(self):
	return True

# OK
def getGeneralConfig_hash(self, objectId=None):
	if objectId:
		objectId = forceObjectId(objectId)
	else:
		objectId = self.host_getIdents(type = 'OpsiConfigserver')[0]
	result = {}
	for (name, values) in self.configState_getValues(objectId = objectId).values()[0].items():
		if values:
			result[name] = values[0]
		else:
			result[name] = u""
	return result

# OK
def getGeneralConfigValue(self, key, objectId=None):
	return self.getGeneralConfig_hash(objectId = objectId).get(key)

# OK
def setGeneralConfig(self, config, objectId=None):
	if objectId:
		objectId = forceObjectId(objectId)
	
	configStates = []
	for (configId, value) in config.items():
		if not objectId or not self.config_getObjects(id = configId):
			self.config_createObjects(
				UnicodeConfig(
					id = configId,
					defaultValues = [ value ],
					possibleValues = [ value ],
					editable = True,
					multiValue = False
				)
			)
		if objectId:
			configStates.append(
				ConfigState(
					configId = configId,
					objectId = objectId,
					values = [ value ]
				)
			)
	if configStates:
		self.configState_createObjects(configStates)

# OK
def setGeneralConfigValue(self, key, value, objectId=None):
	self.setGeneralConfig(config = { key: value }, objectId = objectId)

# OK
def deleteGeneralConfig(self, objectId):
	return self.configState_delete(configId = [], objectId = forceObjectId(objectId))

def setNetworkConfig(self, config, objectId=None):
	raise NotImplementedError("Not Implemented")

def setNetworkConfigValue(self, key, value, objectId=None):
	raise NotImplementedError("Not Implemented")

def getNetworkConfig_hash(self, objectId=None):
	return {}

def getNetworkConfigValue(self, key, objectId=None):
	return None

def deleteNetworkConfig(self, objectId):
	raise NotImplementedError("Not Implemented")

# OK
def getGroupIds_list(self):
	return self.group_getIdents(returnType = 'list')

# OK
def getHostGroupTree_hash(self):
	groups = {}
	childs = {}
	for group in self.group_getObjects(attributes = ['id', 'parentGroupId']):
		if group.getParentGroupId():
			if not childs.has_key(group.getParentGroupId()):
				childs[group.getParentGroupId()] = {}
			childs[group.getParentGroupId()][group.getId()] = {}
		else:
			groups[group.getId()] = {}
	
	def insertGroup(gid, g, gs):
		if gid in gs.keys():
			gs[gid] = g
			return True
		for ng in gs.keys():
			if insertGroup(gid, g, gs[ng]):
				return True
		return False
	
	while childs.keys():
		left = len(childs.keys())
		for groupId in childs.keys():
			if insertGroup(groupId, childs[groupId], groups):
				del childs[groupId]
		if (left == len(childs.keys())):
			raise BackendIOError("Error in host groups")
	return groups

# OK
def createGroup(self, groupId, members=[], description="", parentGroupId=""):
	if not parentGroupId:
		parentGroupId = None
	self.group_createHost(id = groupId, description = description, notes=u'', parentGroupId = parentGroupId)
	objects = []
	for member in members:
		objects.append( ObjectToGroup(groupId = groupId, objectId = member) )
	self.objectToGroup_createObjects(objects)

# OK
def deleteGroup(self, groupId):
	self.group_delete(id = groupId)

# OK
def getHostId(self, hostname=None):
	raise NotImplementedError("Not Implemented")

# OK
def setPXEBootConfiguration(self, hostId, args={}):
	raise NotImplementedError("Not Implemented")

# OK
def unsetPXEBootConfiguration(self, hostId):
	raise NotImplementedError("Not Implemented")

def powerOnHost(self, hostId):
	raise NotImplementedError("Not Implemented")

# OK
def getIpAddress(self, hostId):
	hostId = forceHostId(hostId)
	hosts = self.host_getObjects(attributes = ['ipAddress'], id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	return hosts[0].getIpAddress() or u''

# OK
def createServer(self, serverName, domain, description=None, notes=None):
	id = forceHostId(forceHostname(serverName) + u'.' + forceDomain(domain))
	self.host_createOpsiConfigserver(id = id, description = description, notes = notes)
	return id

# OK
def createClient(self, clientName, domain, description=None, notes=None, ipAddress=None, hardwareAddress=None):
	if not ipAddress: ipAddress = None
	if not hardwareAddress: hardwareAddress = None
	id = forceHostId(forceHostname(clientName) + u'.' + forceDomain(domain))
	self.host_createOpsiClient(id = id, description = description, notes = notes, ipAddress = ipAddress, hardwareAddress = hardwareAddress)
	return id

# OK
def deleteServer(self, serverId):
	self.host_delete(id = forceHostId(serverId))

# OK
def deleteClient(self, clientId):
	self.host_delete(id = forceHostId(clientId))

# OK
def setHostLastSeen(self, hostId, timestamp):
	hostId = forceHostId(hostId)
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hosts[0].setLastSeen(timestamp)
	self.host_updateObject(hosts[0])

# OK
def setHostDescription(self, hostId, description):
	hostId = forceHostId(hostId)
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hosts[0].setDescription(description)
	self.host_updateObject(hosts[0])

# OK
def setHostNotes(self, hostId, notes):
	hostId = forceHostId(hostId)
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hosts[0].setNotes(notes)
	self.host_updateObject(hosts[0])

def getSoftwareInformation_hash(self, hostId):
	raise NotImplementedError("Not Implemented")

def getSoftwareInformation_listOfHashes(self):
	raise NotImplementedError("Not Implemented")

def setSoftwareInformation(self, hostId, info):
	raise NotImplementedError("Not Implemented")

def deleteSoftwareInformation(self, hostId):
	raise NotImplementedError("Not Implemented")

def softwareInformationToProductInstallationStatus(self, hostIds=[]):
	raise NotImplementedError("Not Implemented")
	'''
	This method sets product installation states based on software inventory results.
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	if not type(hostIds) in (list, tuple):
		hostIds = [ hostIds ]
	if not hostIds:
		hostIds = self.getClientIds_list()
	windowsSoftwareIds = {}
	
	for product in self.getProducts_listOfHashes():
		if product.get("windowsSoftwareIds", []):
			for swid in product["windowsSoftwareIds"]:
				windowsSoftwareIds[swid] = product['productId']
	
	errors = []
	for hostId in hostIds:
		try:
			sw = self.getSoftwareInformation_hash(hostId)
			for (softwareId, info) in sw.items():
				if windowsSoftwareIds.has_key(softwareId):
					status = self.getProductInstallationStatus_hash(windowsSoftwareIds[softwareId], hostId)
					if (status.get("installationStatus") == "installed"):
						continue
					self.setProductState(windowsSoftwareIds[softwareId], hostId, installationStatus="installed", packageVersion="0")
		except Exception, e:
			logger.error("softwareInformationToProductInstallationStatus error: %s" % e)
			errors.append(e)
	if errors:
		raise("Error occured: %s" % errors)

def getOpsiHWAuditConf(self, locale):
	return {}
	
def getHardwareInformation_hash(self, hostId):
	raise NotImplementedError("Not Implemented")

def setHardwareInformation(self, hostId, info):
	raise NotImplementedError("Not Implemented")

def deleteHardwareInformation(self, hostId):
	raise NotImplementedError("Not Implemented")

def filterHostsByHardwareInformation(self, hostIds, hwFilter):
	raise NotImplementedError("Not Implemented")
	'''
	Takes a list of host ids and a hardware filter (e.g. { "HW_CLASS.property": ">= 100"} ).
	Returns the list of host ids matching the filter.
	'''
	
	filteredHostIds = []
	compRegex = '([<=>]=?)\s*(.*)$'
	for hostId in hostIds:
		hw = self._execMethod(self.hwinventBackend, 'getHardwareInformation_hash', hostId)
		if not hw:
			continue
		
		matches = False
		for (key, value) in hwFilter.items():
			(hwClass, hwProperty) = key.split('.', 1)
			hwProperty
			comp = ''
			match = re.search(compRegex, value)
			if match:
				comp = match.group(1)
				value = float(match.group(2))
				if (comp == '='):
					comp = '=='
			logger.info("Testing if host '%s' matches '%s.%s' %s '%s'" % (hostId, hwClass, hwProperty, comp, value))
			matches = False
			for device in hw.get(hwClass, []):
				logger.debug("Testing device: %s" % device)
				v = device.get(hwProperty)
				if not v:
					v = device.get(hwProperty.lower())
				
				if not v and value:
					continue
				elif comp:
					if eval('%s %s %s' % (v, comp, value)):
						logger.info("Host '%s' matches '%s.%s' %s '%s'" % (hostId, hwClass, hwProperty, comp, value))
						matches = True
						continue
				else:
					try:
						if re.search(value, str(v), re.I):
							matches = True
							continue
					except Exception, e:
						raise BackendBadValueError("Bad regular expresion '%s': %s" % (value, e))
			if not matches:
				break
		if matches:
			filteredHostIds.append(hostId)
	return filteredHostIds

# OK
def getHost_hash(self, hostId):
	hostId = forceHostId(hostId)
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hash = hosts[0].toHash()
	hash['hostId'] = hash['id']
	match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', hash.get('created', ''))
	if match:
		hash['created'] = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
	match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', hash.get('lastSeen', ''))
	if match:
		hash['lastSeen'] = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
	del hash['type']
	del hash['id']
	return self._hashValuesNoneToEmptyString(hash)

def getClients_listOfHashes(self, serverId=None, depotIds=[], groupId=None, productId=None, installationStatus=None, actionRequest=None, productVersion=None, packageVersion=None, hwFilter=None):
	# TODO: filter
	result = []
	clientIds = []
	if depotIds:
		for (depotId, cIds) in self.configState_getDepotserverIdsToClientIds(depotIds = forceHostIdList(depotIds)).items():
			clientIds.extend(cIds)
	clients = self.host_getObjects(type = 'OpsiClient', id = clientIds)
	for client in clients:
		hash = client.toHash()
		hash['hostId'] = hash['id']
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', hash.get('created', ''))
		if match:
			hash['created'] = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', hash.get('lastSeen', ''))
		if match:
			hash['lastSeen'] = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
		del hash['type']
		del hash['id']
		result.append(self._hashValuesNoneToEmptyString(hash))
	return result
	
def getClientIds_list(self, serverId=None, depotIds=[], groupId=None, productId=None, installationStatus=None, actionRequest=None, productVersion=None, packageVersion=None, hwFilter=None):
	if not serverId: serverId = None
	# TODO: filter
	return self.host_getIdents(type = 'OpsiClient')
	
def getClientIdByMac(self, mac):
	hosts = self.host_getObjects(attributes = ['id'], type = 'OpsiClient', hardwareAddress = forceHardwareAddress(mac))
	if not hosts:
		return u''
	return hosts[0].id
	
def getServerIds_list(self):
	return self.host_getIdents(type = 'OpsiConfigserver')

def getServerId(self, clientId):
	# TODO: clientId
	return self.host_getIdents(type = 'OpsiConfigserver')[0]

def createDepot(self, depotName, domain, depotLocalUrl, depotRemoteUrl, repositoryLocalUrl, repositoryRemoteUrl, network, description=None, notes=None, maxBandwidth=0):
	id = forceHostId(forceHostname(depotName) + u'.' + forceDomain(domain))
	self.host_createOpsiDepotserver(id = id, depotLocalUrl = depotLocalUrl, depotRemoteUrl = depotRemoteUrl, repositoryLocalUrl = repositoryLocalUrl, repositoryRemoteUrl = repositoryRemoteUrl,
					description = description, notes = notes, hardwareAddress = None, ipAddress = None, network = network, maxBandwidth = maxBandwidth)
	self.host_createOpsiConfigserver(id = id, description = description, notes = notes)
	return id
	
def getDepotIds_list(self):
	return self.host_getIdents(type = 'OpsiDepotserver')
	
def getDepot_hash(self, depotId):
	depotId = forceHostId(depotId)
	depots = self.host_getObjects(id = depotId)
	if not depots:
		raise BackendMissingDataError(u"Depot '%s' not found" % depotId)
	hash = depots[0].toHash()
	del hash['type']
	if not hash['ipAddress']:
		try:
			hash['ipAddress'] = socket.gethostbyname(depotId)
		except Exception, e:
			logger.debug(u"Failed to get host by name (%s): %s" % (depotId, e))
	hash['ip'] = hash['ipAddress']
	return self._hashValuesNoneToEmptyString(hash)

def getDepotId(self, clientId=None):
	if not clientId: clientId = None
	return self.configState_getDepotserverId(clientId = clientId)

def deleteDepot(self, depotId):
	self.host_delete(id = forceHostId(depotId))
	
def generateOpsiHostKey(self):
	raise NotImplementedError("Not Implemented")
	return generateOpsiHostKey()
	
def getOpsiHostKey(self, hostId=None):
	if not hostId:
		raise NotImplementedError("Not Implemented")
		return generateOpsiHostKey()
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	return hosts[0].opsiHostKey
	
def setOpsiHostKey(self, hostId, opsiHostKey):
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hosts[0].setOpsiHostKey(opsiHostKey)
	self.host_updateObject(hosts[0])
	
def getMacAddresses_list(self, hostId):
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	if not hosts[0].hardwareAddress:
		return ['']
	return [ hosts[0].hardwareAddress ]
	
def setMacAddresses(self, hostId, macs=()):
	hosts = self.host_getObjects(id = hostId)
	if not hosts:
		raise BackendMissingDataError(u"Host '%s' not found" % hostId)
	hosts[0].setHardwareAddress(macs[0])
	self.host_updateObject(hosts[0])

def getMacAddress(self, hostId):
	return self.getMacAddresses_list(hostId)[0]
	
def setMacAddress(self, hostId, mac):
	self.setMacAddresses(hostId, macs = [ mac ] )
	
def getPcpatchPassword(self, hostId):
	raise NotImplementedError("Not Implemented")

def setPcpatchPassword(self, hostId, password):
	raise NotImplementedError("Not Implemented")

def lockProduct(self, productId, depotIds=[]):
	productOnDepots = self.productOnDepot_getObjects(productId = productId, depotId = depotIds)
	if not productOnDepots:
		raise BackendMissingDataError(u"Product '%s' not found on given depots" % productId)
	for productOnDepot in productOnDepots:
		productOnDepot.setLocked(True)
	self.productOnDepot_updateObjects(productOnDepots)
	
def unlockProduct(self, productId, depotIds=[]):
	productOnDepots = self.productOnDepot_getObjects(productId = productId, depotId = depotIds)
	if not productOnDepots:
		raise BackendMissingDataError(u"Product '%s' not found on given depots" % productId)
	for productOnDepot in productOnDepots:
		productOnDepot.setLocked(False)
	self.productOnDepot_updateObjects(productOnDepots)

def getProductLocks_hash(self, depotIds=[]):
	result = {}
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotIds):
		if not productOnDepot.locked:
			continue
		if not result.has_key(productOnDepot.productId):
			result[productOnDepot.productId] = []
		result[productOnDepot.productId].append(productOnDepot.depotId)
	return result

def createProduct(self, productType, productId, name, productVersion, packageVersion, licenseRequired=0,
		   setupScript="", uninstallScript="", updateScript="", alwaysScript="", onceScript="",
		   priority=0, description="", advice="", productClassNames=(), pxeConfigTemplate='',
		   windowsSoftwareIds=[], depotIds=[]):
	type = forceProductType(productType)
	hash = locals()
	del hash['productType']
	del hash['depotIds']
	del hash['self']
	hash['id'] = hash['productId']
	del hash['productId']
	
	product = Product.fromHash(hash)
	self.product_createObjects(product)
	
	productOnDepots = []
	if not depotIds:
		depotIds = self.host_getIdents(type = 'OpsiDepotserver')
	for depotId in depotIds:
		productOnDepots.append(
			ProductOnDepot(
				productId      = product.id,
				productType    = product.getType(),
				productVersion = product.productVersion,
				packageVersion = product.packageVersion,
				depotId        = depotId ))
	self.productOnDepot_createObjects(productOnDepots)

def createLocalBootProduct(self, productId, name, productVersion, packageVersion, licenseRequired=0,
		   setupScript="", uninstallScript="", updateScript="", alwaysScript="", onceScript="",
		   priority=0, description="", advice="", productClassNames=('localBoot'),
		   windowsSoftwareIds=[], depotIds=[]):
	self.createProduct('localboot', productId, name, productVersion, packageVersion, licenseRequired,
			    setupScript, uninstallScript, updateScript, alwaysScript, onceScript,
			    priority, description, advice, productClassNames, '',
			    windowsSoftwareIds, depotIds)

def createNetBootProduct(self, productId, name, productVersion, packageVersion, licenseRequired=0,
		   setupScript="", uninstallScript="", updateScript="", alwaysScript="", onceScript="",
		   priority=0, description="", advice="", productClassNames=('netboot'), pxeConfigTemplate='',
		   windowsSoftwareIds=[], depotIds=[]):
	self.createProduct('netboot', productId, name, productVersion, packageVersion, licenseRequired,
			    setupScript, uninstallScript, updateScript, alwaysScript, onceScript,
			    priority, description, advice, productClassNames, pxeConfigTemplate,
			    windowsSoftwareIds, depotIds)

def createServerProduct(self, productId, name, productVersion, packageVersion, licenseRequired=0,
		   setupScript="", uninstallScript="", updateScript="", alwaysScript="", onceScript="",
		   priority=10, description="", advice="", productClassNames=('server'),
		   windowsSoftwareIds=[], depotIds=[]):
	raise NotImplementedError("Not Implemented")

def deleteProduct(self, productId, depotIds=[]):
	self.productOnDepot_delete(productId = productId, depotId = depotIds)
	
def getProduct_hash(self, productId, depotId=None):
	result = {}
	if not depotId:
		products = self.product_getObjects(id = productId)
		if not products:
			raise BackendMissingDataError(u"No product with id '%s' found" % productId)
		result = products[0].toHash()
	else:
		productOnDepot = self.productOnDepot_getObjects(productId = productId, depotId = depotId)
		if not productOnDepot:
			raise BackendMissingDataError(u"No product with id '%s' on depot '%s' found" % (productId, depotId))
		productOnDepot = productOnDepot[0]
		products = self.product_getObjects(
					id = productOnDepot.productId,
					productVersion = productOnDepot.productVersion,
					packageVersion = productOnDepot.packageVersion)
		if not products:
			raise BackendMissingDataError(u"Product with id '%s', productVersion '%s', packageVersion '%s' not found" \
				% (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion))
		result = products[0].toHash()
	result['productId'] = result['id']
	del result['id']
	if (result['type'] == 'LocalbootProduct'):
		result['productType'] = 'localboot'
	elif (result['type'] == 'NetbootProduct'):
		result['productType'] = 'netboot'
	else:
		raise BackendBadValueError(u"Unknown product type '%s'" % result['type'])
	del result['type']
	return self._hashValuesNoneToEmptyString(result)
	
def getProducts_hash(self, depotIds=[]):
	result = {}
	if not depotIds:
		depotIds = self.getDepotIds_list()
	for depotId in depotIds:
		result[depotId] = {}
		
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotIds):
		if not result.has_key(productOnDepot.depotId):
			result[productOnDepot.depotId] = {}
		products = self.product_getObjects(
				id = productOnDepot.productId,
				productVersion = productOnDepot.productVersion,
				packageVersion = productOnDepot.packageVersion)
		if not products:
			raise BackendMissingDataError(u"Product with id '%s', productVersion '%s', packageVersion '%s' not found" \
				% (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion))
		res = products[0].toHash()
		res['productId'] = res['id']
		del res['id']
		if (res['type'] == 'LocalbootProduct'):
			res['productType'] = 'localboot'
		elif (res['type'] == 'NetbootProduct'):
			res['productType'] = 'netboot'
		else:
			raise BackendBadValueError(u"Unknown product type '%s'" % res['type'])
		del res['type']
		res = self._hashValuesNoneToEmptyString(res)
		result[productOnDepot.depotId][res['productId']] = res
	return result

def getProducts_listOfHashes(self, depotId=None):
	result = []
	for (productId, productVersion, packageVersion) in self.product_getIdents(returnType = 'tuple'):
		if depotId:
			try:
				result.append(self.getProduct_hash(productId = productId, depotId = depotId))
			except BackendMissingDataError, e:
				pass
		else:
			result.append(self.getProduct_hash(productId = productId))
	return result

def getProductIds_list(self, productType=None, objectId=None, installationStatus=None):
	if not productType:        productType = None
	if not objectId:           objectId = None
	if not installationStatus: installationStatus = None
	type = None
	if   (productType == 'localboot'):
		type = 'LocalbootProduct'
	elif (productType == 'netboot'):
		type = 'NetbootProduct'
	productIds = []
	for (productId, productVersion, packageVersion) in self.product_getIdents(type = type, returnType = 'tuple'):
		if not productId in productIds:
			productIds.append(productId)
	return productIds

def getLocalBootProductIds_list(self, objectId=None, installationStatus=None):
	return self.getProductIds_list('localboot', objectId, installationStatus)

def getNetBootProductIds_list(self, objectId=None, installationStatus=None):
	return self.getProductIds_list('netboot', objectId, installationStatus)

def getServerProductIds_list(self, objectId=None, installationStatus=None):
	return self.getProductIds_list('localboot', objectId, installationStatus)

def getInstallableProductIds_list(self, clientId):
	depotId = self.getDepotId(clientId = clientId)
	result = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		result.append(productOnDepot.productId)
	return result
	
def getInstallableLocalBootProductIds_list(self, clientId):
	depotId = self.getDepotId(clientId = clientId)
	result = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = 'LocalbootProduct'):
		result.append(productOnDepot.productId)
	return result

def getInstallableNetBootProductIds_list(self, clientId):
	depotId = self.getDepotId(clientId = clientId)
	result = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = 'NetbootProduct'):
		result.append(productOnDepot.productId)
	return result

def getInstalledProductIds_list(self, objectId):
	result = []
	for productOnClient in self.productOnClient_getObjects(attributes = ['productId'], clientId = objectId, installationStatus = 'installed'):
		result.append(productOnClient.productId)
	return result

def getUninstalledProductIds_list(self, objectId):
	raise NotImplementedError("Not Implemented")

def getInstalledLocalBootProductIds_list(self, objectId):
	result = []
	for productOnClient in self.productOnClient_getObjects(clientId = objectId, productType = 'LocalbootProduct', installationStatus = 'installed'):
		result.append(productOnClient.productId)
	return result

def getInstalledNetBootProductIds_list(self, objectId):
	result = []
	for productOnClient in self.productOnClient_getObjects(clientId = objectId, productType = 'NetbootProduct', installationStatus = 'installed'):
		result.append(productOnClient.productId)
	return result

def getProvidedLocalBootProductIds_list(self, depotId):
	result = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = 'LocalbootProduct'):
		result.append(productOnDepot.productId)
	return result

def getProvidedNetBootProductIds_list(self, depotId):
	result = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = 'NetbootProduct'):
		result.append(productOnDepot.productId)
	return result

def getProductInstallationStatus_hash(self, productId, objectId):
	productId = forceProductId(productId)
	productOnClients = self.productOnClient_getObjects(productId = productId, clientId = objectId)
	if not productOnClients:
		return  {
			u"installationStatus": u"not_installed",
			u"productId": productId
		}
	hash = productOnClients[0].toHash()
	match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', hash.get('lastStateChange', ''))
	if match:
		hash['lastStateChange'] = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
	return hash
	
def getProductInstallationStatus_listOfHashes(self, objectId):
	depotId = self.configState_getDepotserverId(clientId = objectId)
	products = {}
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		products[productOnDepot.productId] = {
			u"lastStateChange":    u"",
			u"productVersion":     productOnDepot.productVersion,
			u"packageVersion":     productOnDepot.packageVersion,
			u"installationStatus": u"not_installed",
			u"productId":          productOnDepot.productId
		}
	
	for productOnClient in self.productOnClient_getObjects(clientId = objectId):
		lastStateChange = productOnClient.lastStateChange
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', lastStateChange)
		if match:
			lastStateChange = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
		products[productOnClient.productId] = {
			u"lastStateChange":    lastStateChange,
			u"productVersion":     productOnClient.productVersion,
			u"packageVersion":     productOnClient.packageVersion,
			u"installationStatus": productOnClient.installationStatus,
			u"productId":          productOnClient.productId
		}
	return products.values()
	
def setProductState(self, productId, objectId, installationStatus="", actionRequest="", productVersion="", packageVersion="", lastStateChange="", productActionProgress={}):
	if not installationStatus:    installationStatus = None
	if not actionRequest:         actionRequest = None
	if not productVersion:        productVersion = None
	if not packageVersion:        packageVersion = None
	if not lastStateChange:       lastStateChange = None
	if not productActionProgress: productActionProgress = None
	
	depotId = self.configState_getDepotserverId(clientId = objectId)
	productType = None
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		if (productOnDepot.productId == productId):
			productType = productOnDepot.productType
			break
	if not productType:
		raise BackendMissingDataError("Product '%s' not found on depot '%s'" % (productId, depotId))
	
	self.productOnClient_create(
		productId          = productId,
		productType        = productType,
		clientId           = objectId,
		installationStatus = installationStatus,
		actionRequest      = actionRequest,
		actionProgress     = productActionProgress,
		productVersion     = productVersion,
		packageVersion     = packageVersion,
		lastStateChange    = lastStateChange)

def setProductInstallationStatus(self, productId, objectId, installationStatus):
	depotId = self.configState_getDepotserverId(clientId = objectId)
	productType = None
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		if (productOnDepot.productId == productId):
			productType = productOnDepot.productType
			break
	if not productType:
		raise BackendMissingDataError("Product '%s' not found on depot '%s'" % (productId, productType))
	
	self.productOnClient_create(
		productId          = productId,
		productType        = productType,
		clientId           = objectId,
		installationStatus = installationStatus )

def setProductActionProgress(self, productId, hostId, productActionProgress):
	depotId = self.configState_getDepotserverId(clientId = hostId)
	productType = None
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		if (productOnDepot.productId == productId):
			productType = productOnDepot.productType
			break
	if not productType:
		raise BackendMissingDataError("Product '%s' not found on depot '%s'" % (productId, productType))
	
	self.productOnClient_create(
		productId      = productId,
		productType    = productType,
		clientId       = hostId,
		actionProgress = productActionProgress )

def getPossibleProductActions_list(self, productId=None, depotId=None):
	if not depotId: depotId = None
	result = []
	if not productId:
		return [ u'setup', u'uninstall', u'update', u'always', u'once' ]
	product = self.getProduct_hash(productId = productId, depotId = depotId)
	if product['setupScript']:     result.append(u'setup')
	if product['uninstallScript']: result.append(u'uninstall')
	if product['updateScript']:    result.append(u'update')
	if product['alwaysScript']:    result.append(u'always')
	if product['onceScript']:      result.append(u'once')
	return result

def getPossibleProductActions_hash(self, depotId=None):
	result = {}
	if not depotId or not depotId in self.getDepotIds_list():
		depotId = None
	for product in self.getProducts_listOfHashes(depotId = depotId):
		result[product['productId']] = []
		if product['setupScript']:     result[product['productId']].append(u'setup')
		if product['uninstallScript']: result[product['productId']].append(u'uninstall')
		if product['updateScript']:    result[product['productId']].append(u'update')
		if product['alwaysScript']:    result[product['productId']].append(u'always')
		if product['onceScript']:      result[product['productId']].append(u'once')
	return result
	
def getProductActionRequests_listOfHashes(self, clientId, options={}):
	result = []
	for productOnClient in self.productOnClient_getObjects(clientId = clientId):
		result.append({
			u"productId":     productOnClient.productId,
			u"actionRequest": productOnClient.actionRequest
		})
	return result

def getDefaultNetBootProductId(self, clientId):
	raise NotImplementedError("Not Implemented")

def setProductActionRequest(self, productId, clientId, actionRequest):
	depotId = self.configState_getDepotserverId(clientId = clientId)
	productType = None
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		if (productOnDepot.productId == productId):
			productType = productOnDepot.productType
			break
	if not productType:
		raise BackendMissingDataError("Product '%s' not found on depot '%s'" % (productId, productType))
	
	self.productOnClient_create(
		productId     = productId,
		productType   = productType,
		clientId      = clientId,
		actionRequest = actionRequest )

def unsetProductActionRequest(self, productId, clientId):
	self.setProductActionRequest(productId = productId, clientId = clientId, actionRequest = "none")

def _getProductStates_hash(self, objectIds=[], options={}, productType=None):
	if not productType: productType = None
	result = {}
	
	productStatesFound = {}
	for productOnClient in self.productOnClient_getObjects(clientId = objectIds, productType = productType):
		if not result.has_key(productOnClient.clientId):
			result[productOnClient.clientId] = []
		
		if not productStatesFound.has_key(productOnClient.clientId):
			productStatesFound[productOnClient.clientId] = []
		
		lastStateChange = productOnClient.lastStateChange or u''
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', lastStateChange)
		if match:
			lastStateChange = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
		result[productOnClient.clientId].append({
			u"lastStateChange":       lastStateChange,
			u"productVersion":        productOnClient.productVersion or u'',
			u"packageVersion":        productOnClient.packageVersion or u'',
			u"installationStatus":    productOnClient.installationStatus,
			u"actionRequest":         productOnClient.actionRequest,
			u"productActionProgress": productOnClient.actionProgress,
			u"productId":             productOnClient.productId
		})
		productStatesFound[productOnClient.clientId].append( productOnClient.productId)
	
	depotServerIdToClientIds = self.configState_getDepotserverIdsToClientIds(clientIds = objectIds)
	depotServerIdToProductIds = {}
	for depotId in depotServerIdToClientIds.keys():
		depotServerIdToProductIds[depotId] = []
	for productOnDepot in self.productOnDepot_getIdents(depotId = depotServerIdToClientIds.keys(), returnType = 'dict'):
		depotServerIdToProductIds[depotId].append(productOnDepot['productId'])
	
	for (depotId, clientIds) in depotServerIdToClientIds.items():
		for clientId in clientIds:
			if not result.has_key(clientId):
				result[clientId] = []
			if not productStatesFound.has_key(clientId):
				productStatesFound[clientId] = []
			for productId in depotServerIdToProductIds[depotId]:
				if not productId in productStatesFound[clientId]:
					result[clientId].append({
						u"lastStateChange":       u'',
						u"productVersion":        u'',
						u"packageVersion":        u'',
						u"installationStatus":    u'not_installed',
						u"actionRequest":         u'none',
						u"productActionProgress": u'',
						u"productId":             productId
					})
	return result

def getLocalBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'LocalbootProduct')

def getNetBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'NetbootProduct')

def getProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options)

# OK
def getProductPropertyDefinitions_hash(self, depotId=None):
	if not depotId: depotId = None
	result = {}
	propertyNames = {}
	for productOnDepot in self.productOnDepot_getIdents(depotId = depotId, returnType = 'dict'):
		for productProperty in self.productProperty_getObjects(
					productId      = productOnDepot['productId'],
					productVersion = productOnDepot['productVersion'],
					packageVersion = productOnDepot['packageVersion']):
			productId = productProperty.getProductId()
			if not result.has_key(productId):
				result[productId] = []
			if not propertyNames.has_key(productId):
				propertyNames[productId] = {}
			if propertyNames[productId].has_key(productProperty.getPropertyId()):
				continue
			propertyNames[productId][productProperty.getPropertyId()] = 1
			
			result[productId].append({
				'name':        productProperty.getPropertyId(),
				'description': productProperty.getDescription(),
				'values':      forceUnicodeList(productProperty.getPossibleValues()),
				'default':     u','.join(forceUnicodeList(productProperty.getDefaultValues()))
			})
	return result

def getProductPropertyDefinitions_listOfHashes(self, productId, depotId=None):
	raise NotImplementedError(u"Not implemented")

def deleteProductPropertyDefinition(self, productId, name, depotIds=[]):
	raise NotImplementedError(u"Not implemented")

def deleteProductPropertyDefinitions(self, productId, depotIds=[]):
	raise NotImplementedError(u"Not implemented")

def createProductPropertyDefinition(self, productId, name, description=None, defaultValue=None, possibleValues=[], depotIds=[]):
	raise NotImplementedError(u"Not implemented")

def getProductProperties_hash(self, productId, objectId=None):
	if not objectId: objectId = None
	result = {}
	depotId = None
	try:
		depotId = self.configState_getDepotserverId(clientId = objectId)
	except:
		pass
	for productPropertyDefinition in self.getProductPropertyDefinitions_hash(depotId = depotId).get(productId, []):
		result[productPropertyDefinition['name']] = productPropertyDefinition['default']
	for productPropertyState in self.productPropertyState_getObjects(productId = productId, objectId = objectId):
		result[productPropertyState.getPropertyId()] =  u','.join(forceUnicodeList(productPropertyState.getValues()))
	return result
	
def setProductProperties(self, productId, properties, objectId=None):
	if not objectId:
		raise NotImplementedError(u"Not implemented")
	
	productPropertyStates = []
	for (propertyId, value) in properties.items():
		if value.lower() in ('true', 'false'):
			value = forceBool(value)
		productPropertyStates.append(
			ProductPropertyState(
				productId  = productId,
				propertyId = propertyId,
				objectId   = objectId,
				values     = [ value ]
			)
		)
	self.productPropertyState_createObjects(productPropertyStates)
	
def setProductProperty(self, productId, property, value, objectId=None):
	# Implementation
	properties = self.getProductProperties_hash(productId, objectId)
	properties[property] = value
	self.setProductProperties(productId, properties, objectId)
	
def deleteProductProperty(self, productId, property, objectId=None):
	raise NotImplementedError(u"Not implemented")

def deleteProductProperties(self, productId, objectId=None):
	raise NotImplementedError(u"Not implemented")

def getProductDependencies_listOfHashes(self, productId=None, depotId=None):
	if not productId: productId = None
	if not depotId:   depotId = None
	result = []
	if depotId:
		for productOnDepot in self.productOnDepot_getIdents(depotId = depotId, returnType = 'dict'):
			for productDependency in self.productDependency_getObjects(
						productId      = productOnDepot['productId'],
						productVersion = productOnDepot['productVersion'],
						packageVersion = productOnDepot['packageVersion']):
				result.append({
					'productId':                  productDependency.getProductId(),
					'action':                     productDependency.getProductAction(),
					'requiredProductId':          productDependency.getRequiredProductId(),
					'requiredProductClassId':     u'',
					'requiredAction':             productDependency.getRequiredAction() or u'',
					'requiredInstallationStatus': productDependency.getRequiredInstallationStatus() or u'',
					'requirementType':            productDependency.getRequirementType() or u''
				})
	else:
		productIds = []
		for productDependency in self.productDependency_getObjects(productId = productId):
			if productDependency.getProductId() in productIds:
				continue
			productIds.append(productDependency.getProductId())
			result.append({
				'productId':                  productDependency.getProductId(),
				'action':                     productDependency.getProductAction(),
				'requiredProductId':          productDependency.getRequiredProductId(),
				'requiredProductClassId':     u'',
				'requiredAction':             productDependency.getRequiredAction() or u'',
				'requiredInstallationStatus': productDependency.getRequiredInstallationStatus() or u'',
				'requirementType':            productDependency.getRequirementType() or u''
			})
	return result

def createProductDependency(self, productId, action, requiredProductId="", requiredProductClassId="", requiredAction="", requiredInstallationStatus="", requirementType="", depotIds=[]):
	'''
	Creates a product dependency for a specific product and an action.
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return None

def deleteProductDependency(self, productId, action="", requiredProductId="", requiredProductClassId="", requirementType="", depotIds=[]):
	'''
	Deletes a product dependency for a specific product.
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.defaultBackend, 'deleteProductDependency', productId, action, requiredProductId, requiredProductClassId, requirementType, depotIds)

def createLicenseContract(self, licenseContractId="", partner="", conclusionDate="", notificationDate="", expirationDate="", notes=""):
	'''
	Creates a license contract
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'createLicenseContract', licenseContractId, partner, conclusionDate, notificationDate, expirationDate, notes)

def getLicenseContractIds_list(self):
	'''
	Returns the list of known license contract ids
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicenseContractIds_list')

def getLicenseContract_hash(self, licenseContractId):
	'''
	Returns the license contract information of the given license contract id
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicenseContract_hash', licenseContractId)

def getLicenseContracts_listOfHashes(self):
	'''
	Returns the license contract informations for all license contracts
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicenseContracts_listOfHashes')


def deleteLicenseContract(self, licenseContractId):
	'''
	Deletes the license contract given by license contract id
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'deleteLicenseContract', licenseContractId)

def createSoftwareLicense(self, softwareLicenseId="", licenseContractId="", licenseType="", maxInstallations="", boundToHost="", expirationDate=""):
	'''
	Creates a software license
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'createSoftwareLicense', softwareLicenseId, licenseContractId, licenseType, maxInstallations, boundToHost, expirationDate)

def getSoftwareLicenseIds_list(self):
	'''
	Returns the list of known software license ids
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getSoftwareLicenseIds_list')
	
def getSoftwareLicense_hash(self, softwareLicenseId):
	'''
	Returns the software license information of the given software license id
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getSoftwareLicense_hash', softwareLicenseId)

def getSoftwareLicenses_listOfHashes(self):
	'''
	Fetches all software licenses
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getSoftwareLicenses_listOfHashes')

def deleteSoftwareLicense(self, softwareLicenseId, removeFromPools=False):
	'''
	Deletes the software license given by software license id
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'deleteSoftwareLicense', softwareLicenseId, removeFromPools)

def createLicensePool(self, licensePoolId="", description="", productIds=[], windowsSoftwareIds=[]):
	'''
	Creates a license pool
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'createLicensePool', licensePoolId, description, productIds, windowsSoftwareIds)

def getLicensePoolIds_list(self):
	'''
	Returns the list of known license pool ids
	'''
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicensePoolIds_list')

def getLicensePool_hash(self, licensePoolId):
	'''
	Returns the license pool information of the given license pool id
	'''
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicensePool_hash', licensePoolId)

def getLicensePools_listOfHashes(self):
	'''
	Returns all license pools
	'''
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicensePools_listOfHashes')

def deleteLicensePool(self, licensePoolId, deleteLicenses=False):
	'''
	Deletes the license pool given by license pool id
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'deleteLicensePool', licensePoolId, deleteLicenses)

def addSoftwareLicenseToLicensePool(self, softwareLicenseId, licensePoolId, licenseKey=""):
	'''
	Adds a software license to a license pool
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'addSoftwareLicenseToLicensePool', softwareLicenseId, licensePoolId, licenseKey)

def removeSoftwareLicenseFromLicensePool(self, softwareLicenseId, licensePoolId):
	'''
	Removes a software license from a license pool
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'removeSoftwareLicenseFromLicensePool', softwareLicenseId, licensePoolId)

def addProductIdsToLicensePool(self, productIds, licensePoolId):
	'''
	Adds product ids to a license pool
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'addProductIdsToLicensePool', productIds, licensePoolId)
	
def removeProductIdsFromLicensePool(self, productIds, licensePoolId):
	'''
	Removes product ids from a licensePoolId
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'removeProductIdsFromLicensePool', productIds, licensePoolId)

def setWindowsSoftwareIdsToLicensePool(self, windowsSoftwareIds, licensePoolId):
	'''
	Set the windows software ids of a license pool
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'setWindowsSoftwareIdsToLicensePool', windowsSoftwareIds, licensePoolId)

def getLicensePoolId(self, productId="", windowsSoftwareId=""):
	'''
	Set the windows software ids of a license pool
	'''
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicensePoolId', productId, windowsSoftwareId)

def getOrCreateSoftwareLicenseUsage_hash(self, hostId, licensePoolId="", productId="", windowsSoftwareId=""):
	'''
	'''
	# Security
	try:
		self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	except Exception, e:
		self._verifyUser(hostId)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getOrCreateSoftwareLicenseUsage_hash', hostId, licensePoolId, productId, windowsSoftwareId)

def getAndAssignSoftwareLicenseKey(self, hostId, licensePoolId="", productId="", windowsSoftwareId=""):
	'''
	'''
	# Security
	try:
		self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	except Exception, e:
		self._verifyUser(hostId)
	
	# Implementation
	licenseKey = ''
	exception = None
	try:
		modules = self.getOpsiInformation_hash()['modules']
		if modules.get('valid') and modules.get('license_management'):
			licenseKey = self._execMethod(self.licenseBackend, 'getAndAssignSoftwareLicenseKey', hostId, licensePoolId, productId, windowsSoftwareId)
		else:
			logger.info("License management currently disabled")
	except Exception, e:
		exception = e
		logger.warning("Failed to get license key from license management for host '%s', pool '%s', product '%s', softwareid '%s': %s" \
				% (hostId, licensePoolId, productId, windowsSoftwareId, e) )
	
	if not licenseKey:
		# Trying the old way - product keys as product property
		if productId:
			for (k, v) in self.getProductProperties_hash(productId = productId, objectId = hostId).items():
				if (k.lower() == 'productkey'):
					licenseKey = v
					break
	if not licenseKey and exception:
		raise exception
	
	return licenseKey
	
def getLicenseKey(self, productId, clientId):
	'''
	Returns an unused licensekey if available or
	the license key assigend to a specific client
	! do not use ! deprecated !
	'''
	# Implementation
	return self.getAndAssignSoftwareLicenseKey(hostId = clientId, productId = productId)

def getSoftwareLicenseUsages_listOfHashes(self, hostIds=[], licensePoolIds=[]):
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getSoftwareLicenseUsages_listOfHashes', hostIds, licensePoolIds)

def setSoftwareLicenseUsage(self, hostId, licensePoolId, softwareLicenseId, licenseKey="", notes=""):
	'''
	Edits the registered license key and the notes for a given assignment of hostId, softwareLicenseId and licensePoolId
	'''
	# Security
	try:
		self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	except Exception, e:
		self._verifyUser(hostId)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'setSoftwareLicenseUsage', hostId, licensePoolId, softwareLicenseId, licenseKey, notes)

def deleteSoftwareLicenseUsage(self, hostId, softwareLicenseId="", licensePoolId="", productId="", windowsSoftwareId=""):
	'''
	Removes the registration of a softwareLicense for a host
	'''
	# Security
	try:
		self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	except Exception, e:
		self._verifyUser(hostId)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'deleteSoftwareLicenseUsage', hostId, softwareLicenseId, licensePoolId, productId, windowsSoftwareId)

def deleteAllSoftwareLicenseUsages(self, hostIds):
	'''
	Frees all assigned licenses
	'''
	# Security
	try:
		self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	except Exception, e:
		if not type(hostIds) is list or (len(hostIds) != 1):
			raise
		self._verifyUser(hostIds[0])
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'deleteAllSoftwareLicenseUsages', hostIds)
	
def getLicenseStatistics_hash(self):
	'''
	Returns informations about free, used and avaliable licenses
	'''
	# Security
	self._verifyGroupMembership(SYSTEM_ADMIN_GROUP)
	
	# Implementation
	return self._execMethod(self.licenseBackend, 'getLicenseStatistics_hash')


