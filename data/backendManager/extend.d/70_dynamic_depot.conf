# -*- coding: utf-8 -*-

global depotSelectionAlgorithmByNetworkAddress
depotSelectionAlgorithmByNetworkAddress = \
'''
def selectDepot(clientConfig, masterDepot, alternativeDepots=[]):
	selectedDepot = masterDepot
	logger.info(u"Choosing depot from list of depots:")
	logger.info(u"   Master depot: %s" % masterDepot)
	for alternativeDepot in alternativeDepots:
		logger.info(u"   Alternative depot: %s" % alternativeDepot)
	if alternativeDepots:
		import socket, struct
		# Calculate bitmask of host's ipaddress
		n = clientConfig['ipAddress'].split('.')
		for i in range(4):
			n[i] = forceInt(n[i])
		ip = (n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]

		depots = [ masterDepot ]
		depots.extend(alternativeDepots)
		for depot in depots:
			if not depot.networkAddress:
				logger.warning(u"Network address of depot '%s' not known" % depot)
				continue
			(network, netmask) = depot.networkAddress.split(u'/')
			while (network.count('.') < 3):
				network = network + u'.0'
			if (netmask.find('.') == -1):
				netmask = forceUnicode(socket.inet_ntoa(struct.pack('>I',0xffffffff ^ (1 << 32 - forceInt(netmask)) - 1)))
			while (netmask.count('.') < 3):
				netmask = netmask + u'.0'

			logger.debug(u"Testing if ip %s is part of network %s/%s" % (clientConfig['ipAddress'], network, netmask))

			n = network.split('.')
			for i in range(4):
				n[i] = int(n[i])
			network = (n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]
			n = netmask.split('.')
			for i in range(4):
				n[i] = int(n[i])
			netmask = (n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]

			wildcard = netmask ^ 0xFFFFFFFFL
			if (wildcard | ip == wildcard | network):
				logger.notice(u"Choosing depot with networkAddress %s for ip %s" % (depot.networkAddress, clientConfig['ipAddress']))
				selectedDepot = depot
				break
			else:
				logger.info(u"IP %s does not match networkAddress %s of depot %s" % (clientConfig['ipAddress'], depot.networkAddress, depot))
	return selectedDepot
'''

global depotSelectionAlgorithmByLatency
depotSelectionAlgorithmByLatency = \
'''
def selectDepot(clientConfig, masterDepot, alternativeDepots=[]):
	selectedDepot = masterDepot
	logger.info(u"Choosing depot from list of depots:")
	logger.info(u"   Master depot: %s" % masterDepot)
	for alternativeDepot in alternativeDepots:
		logger.info(u"   Alternative depot: %s" % alternativeDepot)
	if alternativeDepots:
		from OPSI.Util.Ping import ping
		from OPSI.Util.HTTP import urlsplit
		depots = [ masterDepot ]
		depots.extend(alternativeDepots)
		latency = {}
		for depot in depots:
			if not depot.repositoryRemoteUrl:
				continue
			try:
				(scheme, host, port, baseurl, username, password) = urlsplit(depot.repositoryRemoteUrl)

				# To increase the timeout (in seconds) for the ping you
				# can implement it in the following way:
				#  depotLatency = ping(host, timeout=5)
				depotLatency = ping(host)
				if depotLatency is None:
					logger.info(u"Ping to depot {0} timed out.".format(depot))
				else:
					logger.info(u"Latency of depot %s: %0.3f ms" % (depot, depotLatency * 1000))
					latency[depot] = depotLatency
			except Exception, e:
				logger.warning(e)

		if latency:
			minValue = 1000
			for (depot, value) in latency.items():
				if (value < minValue):
					minValue = value
					selectedDepot = depot
			logger.notice(u"Choosing depot %s with minimum latency %0.3f ms" % (selectedDepot, minValue*1000))
	return selectedDepot
'''

global depotSelectionAlgorithmByMasterDepotAndLatency
depotSelectionAlgorithmByMasterDepotAndLatency = \
'''
def selectDepot(clientConfig, masterDepot, alternativeDepots=[]):
	def getLatencyInformation(depots):
		from OPSI.Util.Ping import ping
		from OPSI.Util.HTTP import urlsplit

		latency = {}
		for depot in depots:
			if not depot.repositoryRemoteUrl:
				continue

			try:
				(scheme, host, port, baseurl, username, password) = urlsplit(depot.repositoryRemoteUrl)
				depotLatency = ping(host)

				if depotLatency is None:
					logger.info(u"Ping to depot {0} timed out.".format(depot))
				else:
					logger.info(u"Latency of depot %s: %0.3f ms" % (depot, depotLatency * 1000))
					latency[depot] = depotLatency
			except Exception, e:
				logger.warning(e)
		return latency

	def getDepotWithLowestLatency(latency):
		selectedDepot = None
		if latency:
			minValue = 1000
			for (depot, value) in latency.items():
				if not value:
					continue
				if (value < minValue):
					minValue = value
					selectedDepot = depot
			logger.notice(u"Choosing depot %s with minimum latency %0.3f ms" % (selectedDepot, minValue*1000))

		return selectedDepot

	logger.info(u"Choosing depot from list of depots:")
	logger.info(u"   Master depot: %s" % masterDepot)
	for alternativeDepot in alternativeDepots:
		logger.info(u"   Alternative depot: %s" % alternativeDepot)

	if alternativeDepots:
		from collections import defaultdict

		# Mapping of depots to its master.
		# key: Master depot
		# value: All slave depots + master
		depotsByMaster = defaultdict(list)

		allDepots = [masterDepot] + alternativeDepots

		for depot in allDepots:
			if depot.masterDepotId:
				depotsByMaster[depot.masterDepotId].append(depot)
			else:
				depotsByMaster[depot.id].append(depot)

		depotsWithLatency = getLatencyInformation(depotsByMaster[masterDepot.id])
		depotWithLowestLatency = getDepotWithLowestLatency(depotsWithLatency)

		logger.info('Depot with lowest latency: {0}'.format(depotWithLowestLatency))
		if not depotWithLowestLatency:
			logger.info('No depot with lowest latency. Falling back to master depot.')
			depotWithLowestLatency = masterDepot

		return depotWithLowestLatency

	return masterDepot
'''


def getDepotSelectionAlgorithm(self):
	#return depotSelectionAlgorithmByMasterDepotAndLatency
	#return depotSelectionAlgorithmByLatency
	return depotSelectionAlgorithmByNetworkAddress


def getBytes(self, num):
	if (num <= 0):
		return ""
	len128 = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
	bytes = ""
	while (len(bytes) < num):
		bytes += len128
	if (len(bytes) > num):
		bytes = bytes[:num]
	return bytes
