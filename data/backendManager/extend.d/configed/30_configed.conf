# -*- coding: utf-8 -*-

global OrderRequirement
class OrderRequirement:
	'''Represents a request for ordering of two elements with a notice if it is fulfilled'''
	
	def __init__(self, prior, posterior, fulfilled=False):
		self.prior     = forceInt(prior)
		self.posterior = forceInt(posterior)
		self.fulfilled = forceBool(fulfilled)
	
	def __unicode__(self):
		return u"<OrderRequirement prior '%s', posterior '%s', fulfilled '%s'>" % (self.prior, self.posterior, self.fulfilled)
		
	def __str__(self):
		return unicode(self).encode("utf-8")
	
	__repr__ = __unicode__

global Requirements
class Requirements:
	'''Comprises a list with ordering requirements and ordered lists of them'''
	
	def __init__(self, allItemsCount):
		self.list = []
		self.orderByPrior=[]
		self.orderByPosterior=[]
	
	def add(self, requirement):
		assert isinstance(requirement, OrderRequirement)
		self.list.append(requirement)
		# Extend the other lists by dummy valuesnoInListOrderedByPriors
		self.orderByPrior.append(-1)
		self.orderByPosterior.append(-1)
		logger.debug2(u"Length of list: %d" % len(self.list))
		logger.debug2(u"Length of orderByPrior: %d" % len(self.orderByPrior))
		
		# Continue building the transform map of list indices 
		# such that the transformed list is ordered by its prior values
		# therefore:
		#  Determine first the place of the added item 
		#  in the ordered sequence i -> list[orderByPrior[i]]
		#  then fix orderByPrior such that it gets this place
		i = 0
		located = False
		while (i < len(self.list)-1) and not located:
			logger.debug2("Requirement.prior: %s, self.list[self.orderByPrior[i]].prior: %s " % (requirement.prior, self.list[self.orderByPrior[i]].prior))
			if (requirement.prior > self.list[self.orderByPrior[i]].prior):
				i += 1
			else:
				located = True
				# we take the first place that fits to the ordering	
				# shift all items by one place
				j = len(self.list) - 1
				while (j > i):
					self.orderByPrior[j] = self.orderByPrior[j-1]
					j -= 1
				# finally we map place i to the new element
				self.orderByPrior[i] = len(self.list) - 1
		
		if not located:
			# noInListOrderedByPriors
			# if i = len(self.list) - 1 nothing is moved
			self.orderByPrior[i] = len(self.list) - 1
			
		logger.debug2(u"Set orderByPrior[%d] = %d" % (i, (len(self.list) - 1) ))
			
		# The analogous procedure to get a transformation
		# i -> orderByPosterior[i] such that the sequence 
		# i ->  self.list[orderByPosterior[i]]
		# is ordered by the posterior values
		
		i = 0
		located = False
		while (i < len(self.list) - 1) and not located:
			logger.debug2("Requirement.posterior %s, self.list[self.orderByPosterior[i]].posterior) %s " % (requirement.posterior, self.list[self.orderByPosterior[i]].posterior))
			if requirement.posterior > self.list[self.orderByPosterior[i]].posterior:
				i += 1
			else:
				located = True
				# We take the first place that fits to the ordering	
				# shift all items by one place
				j = len(self.list) - 1
				while (j > i):
					self.orderByPosterior[j] = self.orderByPosterior[j-1]
					j -= 1
				# Finally we map place i to the new element
				self.orderByPosterior[i] = len(self.list) - 1
		
		if not located:
			# If i = len(self.list) - 1 nothing is moved
			self.orderByPosterior[i] = len(self.list) - 1
	
	
	def posteriorIndexOf(self, posti):
		'''searches first occurrence of posti as posterior value in the posterior-ordered sequence of requirements'''

		j = 0
		searching = True
		while (j < len(self.list)) and searching:
			candidate = self.list[self.orderByPosterior[j]]
			if candidate.fulfilled or (candidate.posterior < posti):
				j += 1
			else:
				searching = False
		
		if searching:
			# All candidates were less than the comparevalue or were not to be regarded any more
			return -1
		else:
			# Candidate is not fulfilled and has posterior value >= posti
			if (candidate.posterior == posti):
				return j
			else:
				# There are no more possible occurrences of posterior
				return -1
	
	def indexOfFirstNotFulfilledRequirementOrderedByPrior(self):
		i = 0
		found = False
		while not found and (i < len(self.list)):
			if (self.list[self.orderByPrior[i]].fulfilled):
				i = i + 1
			else:
				found = True
		if not found:
			return -1
		else:
			return i
	
	def firstPriorNotOccurringAsPosterior(self, startI):
		j = startI
		found = False
		candidate = self.list[self.orderByPrior[startI]].prior
		lastcandidate = -1
		errorS0 = u'Potentially conflicting requirements for:'
		
		while (j < len(self.list)) and not found:
			if not self.list[self.orderByPrior[j]].fulfilled and (self.posteriorIndexOf(candidate) == -1):
				# If requ j still not fulfilled and candidate does not occur 
				# as posterior among the not fulfilled
				# then we adopt candidate (i.e. the prior element of requ j in requ list ordered by priors)
				# as next element in our ordered sequence
				found = True
			else:
				if (self.posteriorIndexOf(candidate) > -1) and ( lastcandidate != candidate ): 
					errorS0 = u"%s %s" % (errorS0, candidate)
					lastcandidate = candidate
				# Go on searching
				j += 1
				if (j < len(self.list)):
					candidate = self.list[self.orderByPrior[j]].prior
		if found:
			noInListOrderedByPriors = j
			return (candidate, noInListOrderedByPriors)
		
		raise OpsiProductOrderingError(errorS0)
	
	def getCount(self):
		return len(self.list)
	
	def getRequList(self):
		return self.list
	
	def getOrderByPrior(self):
		return self.orderByPrior
	
	def getOrderByPosteriors(self):
		return self.orderByPosteriors
		
global OrderBuild
class OrderBuild:
	'''Describes the building of an ordering'''
	
	def __init__(self,elementCount, requs):
		self.ordering = []
		self.elementCount = elementCount
		self.errorFound = False
		self.allFulfilled = False
		assert isinstance(requs, Requirements)
		self.requs = requs
		self.indexIsAmongPosteriors = []
		j = 0
		while (j < elementCount):
			self.indexIsAmongPosteriors.append(False)
			j += 1
		self.indexUsed = []
		j = 0
		while (j < elementCount):
			self.indexUsed.append(False)
			j += 1
		self.usedCount = 0
		
	def proceed(self):
		result = True
		lastSortedCount = 0
		if (self.usedCount >= self.elementCount):
			return result
		
		indexRequToFulfill = self.requs.indexOfFirstNotFulfilledRequirementOrderedByPrior()
		if (indexRequToFulfill == -1):
			self.allFulfilled = True
			# Get the posteriors that did not occur as priors
			j = 0
			while (j < self.elementCount):
				if self.indexIsAmongPosteriors[j] and not self.indexUsed[j]:
					self.ordering.append(j)
					self.indexUsed[j] = True
					self.usedCount = self.usedCount + 1
				j += 1
			lastSortedCount = self.usedCount
			
			# Take rest from list
			j = 0
			while (j < self.elementCount):
				if not self.indexUsed[j]:
					self.ordering.append(j)
					self.indexUsed[j] = True
					self.usedCount = self.usedCount + 1
				j += 1
					
			# Move the sorted items to the end of the list
			if (lastSortedCount > 0):
				newordering = []
				k = 0
				while (k < self.elementCount):
					newordering.append(k)
					k += 1
					
				# Rearrange not sorted elements
				for k in range(self.elementCount - lastSortedCount):
					newordering[k] = self.ordering[lastSortedCount + k]
				
				# Sorted elements
				for k in range(lastSortedCount):
					newordering[self.elementCount - lastSortedCount + k] = self.ordering[k] 

				# Put back
				self.ordering = newordering
		else:
			# At indexRequToFulfill we found a not fulfilled requirement, lets try to fulfill a requirement
			# look only at not fulfilled reqirements
			# Find the first one, in ordering by priors, with the property that it does not occur as posterior
			# take it as newEntry for the ordered list
			# Automatically any requirement is fulfilled where newEntry is the prior; do the markings 
			
			(newEntry, requNoInListOrderedByPriors) = self.requs.firstPriorNotOccurringAsPosterior(indexRequToFulfill)
			if (newEntry == -1):
				result = False
			else:
				self.ordering.append(newEntry)
				#self.ordering[self.usedCount] = newEntry
				self.usedCount = self.usedCount + 1
				# Mark all requirements with candidate in prior position as fulfilled and collect the posteriors
				k = requNoInListOrderedByPriors
				orderByPrior = self.requs.getOrderByPrior()
				requK = self.requs.getRequList()[orderByPrior[k]]
				while (k < self.requs.getCount()) and (newEntry == requK.prior):
					requK.fulfilled = True
					self.indexIsAmongPosteriors[ requK.posterior ] = True
					k += 1
					if (k < self.requs.getCount()):
						requK = self.requs.getRequList()[orderByPrior[k]]
				self.indexUsed[newEntry] = True
		return result
	
	def getOrdering(self):
		return self.ordering

def _getProductStates_hash(self, objectIds=[], options={}, productType=None):
	#based on productOnClients 
	if not productType: productType = None
	result = {}
	
	productHasPriority = {}
	priorityClasses = {}
	
	for product in self.product_getObjects():
		prio = product.priority
		if not prio:
			prio = 0
		productHasPriority[product.id]= prio
		
		if not priorityClasses.has_key(prio):
			priorityClasses[prio] = []
		priorityClasses[prio] .append(product.id)
	
	#self.backend_setOptions({"addProductOnClientDefaults": True})
	productOnClients = self.productOnClient_getObjects(clientId = objectIds, productType = productType)
	
	
	for productOnClient in productOnClients:
		if not result.has_key(productOnClient.clientId):
			result[productOnClient.clientId] = []
		lastStateChange = productOnClient.modificationTime or u''
		match = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)$', lastStateChange)
		if match:
			lastStateChange = u'%s%s%s%s%s%s' % ( match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6) )
			
		actionSequence = productHasPriority[productOnClient.productId];
		if not actionSequence:
			actionSequence = 0
			
		result[productOnClient.clientId].append({
			u"lastStateChange":     lastStateChange,
			u"productVersion":      productOnClient.productVersion or u'',
			u"packageVersion":      productOnClient.packageVersion or u'',
			u"targetConfiguration": productOnClient.targetConfiguration or u'',
			u"lastAction":          productOnClient.lastAction or u'',
			u"installationStatus":  productOnClient.installationStatus,
			u"actionRequest":       productOnClient.actionRequest,
			u"actionProgress":      productOnClient.actionProgress or u'',
			u"actionResult":        productOnClient.actionResult or u'',
			u"productId":           productOnClient.productId,
			u"productPriority":	productHasPriority[productOnClient.productId],
			u"actionSequence": 	actionSequence
			#u"actionSequence": 	productOnClient.actionSequence
		})
	return result

def getLocalBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'LocalbootProduct')

def getNetBootProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options, productType = 'NetbootProduct')

def getProductStates_hash(self, objectIds=[], options={}):
	return self._getProductStates_hash(objectIds = objectIds, options = options)

def getProductProperties(self, depotId, objectIds):
	result = {}
	addProductPropertyStateDefaults = self._backend.backend_getOptions().get('addProductPropertyStateDefaults', False)
	try:
		self._backend.backend_setOptions( { 'addProductPropertyStateDefaults': True } )
		productIds = []
		for productOnDepot in self.productOnDepot_getIdents(returnType = 'dict'):
			productIds.append(productOnDepot['productId'])
		
		for productPropertyState in self.productPropertyState_getObjects(productId = productIds, objectId = objectIds):
			if not result.has_key(productPropertyState.objectId):
				result[productPropertyState.objectId] = {}
			if not result[productPropertyState.objectId].has_key(productPropertyState.productId):
				result[productPropertyState.objectId][productPropertyState.productId] = {}
			result[productPropertyState.objectId][productPropertyState.productId][productPropertyState.propertyId] = u','.join(forceUnicodeList(productPropertyState.getValues()))
	finally:
		self._backend.backend_setOptions( { 'addProductPropertyStateDefaults': addProductPropertyStateDefaults } )
	return result
	
	
def _getProducts_hash(self, depotIds=[]):
	result = {}
	for depotId in depotIds:
		result[depotId] = {}
	
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotIds):
		if not result.has_key(productOnDepot.depotId):
			result[productOnDepot.depotId] = {}
		product = products.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion)
		if not product:
			raise BackendMissingDataError(u"Product with id '%s', productVersion '%s', packageVersion '%s' not found" \
				% (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion))
		result[productOnDepot.depotId][productOnDepot.productId] = self._productToHash(product)
	return result
	

def getProductsInDepot(self, depotId=None, productType=None):
	depotIds = self.host_getIdents(type = 'OpsiDepotserver', returnType = 'unicode')
	products = self.product_getObjects()
	
	if depotId in depotIds:
		filteredProducts = []
		productsByIdAndVersion = {}
		for product in products:
			if not productsByIdAndVersion.has_key(product.id):
				productsByIdAndVersion[product.id] = {}
			if not productsByIdAndVersion[product.id].has_key(product.productVersion):
				productsByIdAndVersion[product.id][product.productVersion] = {}
			productsByIdAndVersion[product.id][product.productVersion][product.packageVersion] = product
			
		for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = productType):
			product = productsByIdAndVersion.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion)
			if product:
				filteredProducts.append(product)
		products = filteredProducts
		
	return products

def getProductInfos_hash(self, depotId=None):
	products = self.getProductsInDepot(depotId)
	
	result = {}
	for product in products:
		result[product.id] = {
			'name':            product.name,
			'description':     product.description,
			'advice':          product.advice,
			'priority':        product.priority,
			'productVersion':  product.productVersion,
			'packageVersion':  product.packageVersion,
			'actions':         [ u'none' ]
		}
		if product.setupScript:     result[product.id]['actions'].append(u'setup')
		if product.uninstallScript: result[product.id]['actions'].append(u'uninstall')
		if product.updateScript:    result[product.id]['actions'].append(u'update')
		if product.alwaysScript:    result[product.id]['actions'].append(u'always')
		if product.onceScript:      result[product.id]['actions'].append(u'once')
		if product.customScript:    result[product.id]['actions'].append(u'custom')
	return result

def getProductOrdering(self, depotId):
	sortAlgorithm = "product_only"
	configs = self.config_getObjects(id = "product_sort_algorithm")
	if configs and "product_on_client" in configs[0].getDefaultValues():
		sortAlgorithm = "product_on_client"
	if (sortAlgorithm == "product_on_client"):
		return self.getProductOrdering_product_on_client(depotId)
	else:
		return self.getProductOrdering_product_only(depotId)

def getProductOrdering_product_on_client(self, depotId):
	productOnClients    = []
	availableProducts   = []
	productDependencies = []
	productIds          = []
	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId):
		products = self.product_getObjects(
				id             = productOnDepot.productId,
				type           = productOnDepot.productType,
				productVersion = productOnDepot.productVersion,
				packageVersion = productOnDepot.packageVersion,
		)
		if not products:
			continue
		product = products[0]
		availableProducts.append(product)
		productIds.append(product.id)
		if not product.setupScript:
			continue
		productOnClients.append(
			ProductOnClient(
				clientId       = 'hostname.domain.tld',
				productId      = product.id,
				productType    = product.getType(),
				productVersion = product.productVersion,
				packageVersion = product.packageVersion,
				actionRequest  = 'setup'
			)
		)
		productDependencies.extend(
			self.productDependency_getObjects(
				productId      = product.id,
				productVersion = product.productVersion,
				packageVersion = product.packageVersion,
				productAction  = 'setup'
			)
		)
	
	sortedList = []
	for productOnClient in OPSI.SharedAlgorithm.generateProductOnClientSequence(productOnClients, availableProducts, productDependencies):
		sortedList.append(productOnClient.productId)
	result  = {}
	result["not_sorted"] = productIds
	result["sorted"] = sortedList
	return result
	
def getProductOrdering_product_only(self, depotId):
	
	products = self.getProductsInDepot(depotId, "LocalbootProduct")
	# If depotId = none we get multiple products for a depotId
	
	# Build priority classes and indices
	productIds = [] 
	#self.getProductIds_list(objectId=depotId)
	priorityClasses = {}
	productIndexInClass = {}
	productById = {}
	for product in products:
		productIds.append(product.id)
		productById[product.id] = product
		prio = str(0)
		if product.priority:
			prio = str(product.priority)
		if not priorityClasses.has_key(prio):
			priorityClasses[prio] = []
		priorityClasses[prio] .append(product.id)
		productIndexInClass[product.id] = len(priorityClasses[prio])-1
	
	# return priorityClasses
	# test return (priorityClasses["0"][productIndexInClass[u"preloginloader"]] ) == u"preloginloader"  
	# 
	# Requirements are list of pairs (install_prior, install_posterior)
	# We treat only setup requirements
	setupRequirements = []
	
	dependencies = self.getProductDependencies_listOfHashes("", depotId)
	
	for dependency in dependencies:
		if (dependency["action"] == u"setup"):
			if   (dependency["requirementType"] == u"before"):
				if (dependency[u"requiredInstallationStatus"] == u"installed") or (dependency[u"requiredAction"] == u"setup"):  
					setupRequirements.append([dependency[u"requiredProductId"], dependency[u"productId"]])
			
			elif (dependency[u"requirementType"] == u"after"):
				if (dependency[u"requiredInstallationStatus"] == u"installed") or (dependency[u"requiredAction"] == u"setup"):  
					setupRequirements.append([dependency[u"productId"], dependency[u"requiredProductId"]])

	requirementsByClasses = {}
	
	for requ in setupRequirements:
		prod1 = requ[0]
		prod2 = requ[1]
		prio1 = productById[prod1].priority
		if not prio1:
			prio1 = 0
		prio2 = productById[prod2].priority
		if not prio2:
			prio2 = 0
			
		if (prio1 > prio2):
			logger.notice(u"The ordering is guaranteed by the priority handling")
		elif (prio1 < prio2):
			logger.info(u"Dependency declaration contradicts priority declaration, will be ignored")
		else:
			prioclasskey = str(prio1)
			if not requirementsByClasses.has_key(prioclasskey):
				requirementsByClasses[prioclasskey] = []
			requirementsByClasses[prioclasskey].append([productIndexInClass[prod1],productIndexInClass[prod2]]) 
	
	prioRange = []
	for r in range(201):
		prioRange.append(100 - r)
	
	foundClasses = []
	orderingsByClasses = {}
	for p in prioRange:
		prioclasskey = str(p)
		if not priorityClasses.has_key(prioclasskey):
			continue
		foundClasses.append(prioclasskey)
		prioclass = priorityClasses[prioclasskey]
		
		if requirementsByClasses.has_key(prioclasskey):
			requs = requirementsByClasses[prioclasskey]
			
			requObjects = Requirements(len(prioclass))
			for item in requs:
				requObjects.add(OrderRequirement(item[0], item[1], False))
			
			ob = OrderBuild(len(prioclass), requObjects)
			for k in range(len(prioclass)):
				ob.proceed()
			orderingsByClasses[prioclasskey]  = ob.getOrdering()
	
	sortedList = []
	for prioclasskey in foundClasses:
		prioclass =  priorityClasses[prioclasskey]
		if orderingsByClasses.has_key(prioclasskey):
			ordering = orderingsByClasses[prioclasskey]
			for idx in ordering:
				sortedList.append(prioclass[idx])
		else:
			for element in prioclass:
				sortedList.append(element)
	result  = {}
	result["not_sorted"] = productIds
	result["sorted"] = sortedList
	return result
	
