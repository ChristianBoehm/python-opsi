# -*- coding: utf-8 -*-

def setProductActionRequestWithDependencies(self, productId, clientId, actionRequest, force=False):
	depotId = self.getDepotId(clientId=clientId)
	if not self.productOnDepot_getObjects(depotId=depotId, productId=productId):
		raise BackendMissingDataError("Product '%s' not found on depot '%s'" % (productId, depotId))

	productOnClientsByProductId = {}
	addProductOnClientDefaults = self._backend.backend_getOptions().get("addProductOnClientDefaults", False)
	try:
		self._backend.backend_setOptions({"addProductOnClientDefaults": True})
		productOnClients = self._backend.productOnClient_getObjects(clientId=clientId)
	finally:
		self._backend.backend_setOptions({"addProductOnClientDefaults": addProductOnClientDefaults})

	for poc in productOnClients:
		if poc.getProductId() not in productOnClientsByProductId:
			productOnClientsByProductId[poc.getProductId()] = poc

	productOnClients = []

	if productId in productOnClientsByProductId:
		productOnClients.append(productOnClientsByProductId[productId])
	else:
		productOnClients.append(ProductOnClient(
			productId=productId,
			productType='LocalbootProduct',
			clientId=clientId,
			installationStatus='not_installed'
		))


	if productOnClients[0].getActionRequest() != actionRequest:
		productOnClients[0].setActionRequest(actionRequest)

		productOnClientsWithDependencies = self._backend.productOnClient_addDependencies(productOnClients)
		if productOnClientsWithDependencies:
			for poc in productOnClientsWithDependencies:
				if poc.getProductId() == productId:
					if poc.getActionRequest() != actionRequest:
						raise BackendIOError("Error occured by resolving the dependendcies that configured in product: '%s'. No ProductAction will be set." % productId)

			for poc in productOnClientsWithDependencies:
				if poc.getProductId() == productId:
					continue
				elif poc.getProductId() in productOnClientsByProductId:
					if force or productOnClientsByProductId[poc.getProductId()].getInstallationStatus() != "installed":
						requiredProduct = productOnClientsByProductId[poc.getProductId()]
						requiredProduct.setActionRequest(poc.getActionRequest())
						productOnClients.append(requiredProduct)

			self._backend.productOnClient_updateObjects(productOnClients)


def userIsReadOnlyUser(self):
	return self.accessControl_userIsReadOnlyUser()


def getServiceTime(self, utctime = False):
	if utctime:
		return str(datetime.datetime.utcnow())
	else:
		return str(datetime.datetime.now())


def getSoftwareAuditDataCount(self):
	"""Get the count of data relevant to the software audit."""
	return len(self.auditSoftware_getObjects()) + len(self.auditSoftwareOnClient_getObjects())


def getHardwareAuditDataCount(self):
	"""Get the count of data relevant to the hardware audit."""
	return len(self.auditHardware_getObjects()) + len(self.auditHardwareOnHost_getObjects())


productOrderingCache = {}
def getProductOrdering(self, depotId, sortAlgorithm = None):
	global productOrderingCache
	if not sortAlgorithm:
		sortAlgorithm = "algorithm2"
		configs = self.config_getObjects(id = "product_sort_algorithm")
		if configs and ("product_on_client" in configs[0].getDefaultValues() or "algorithm1" in configs[0].getDefaultValues()):
			sortAlgorithm = "algorithm1"

	productOnClients    = []
	availableProducts   = []
	productDependencies = []
	productIds          = []

	productsByIdAndVersion = {}
	for product in self.product_getObjects(type = "LocalbootProduct"):
		if not productsByIdAndVersion.has_key(product.id):
			productsByIdAndVersion[product.id] = {}
		if not productsByIdAndVersion[product.id].has_key(product.productVersion):
			productsByIdAndVersion[product.id][product.productVersion] = {}
		productsByIdAndVersion[product.id][product.productVersion][product.packageVersion] = product

	productsDependenciesByIdAndVersion = {}
	for productDependency in self.productDependency_getObjects(productAction = "setup"):
		if not productsDependenciesByIdAndVersion.has_key(productDependency.productId):
			productsDependenciesByIdAndVersion[productDependency.productId] = {}
		if not productsDependenciesByIdAndVersion[productDependency.productId].has_key(productDependency.productVersion):
			productsDependenciesByIdAndVersion[productDependency.productId][productDependency.productVersion] = {}
		if not productsDependenciesByIdAndVersion[productDependency.productId][productDependency.productVersion].has_key(productDependency.packageVersion):
			productsDependenciesByIdAndVersion[productDependency.productId][productDependency.productVersion][productDependency.packageVersion] = []
		productsDependenciesByIdAndVersion[productDependency.productId][productDependency.productVersion][productDependency.packageVersion].append(productDependency)

	for productOnDepot in self.productOnDepot_getObjects(depotId = depotId, productType = "LocalbootProduct"):
		product = productsByIdAndVersion.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion)
		if not product:
			continue
		availableProducts.append(product)
		productIds.append(product.id)
		if not product.setupScript:
			continue
		productOnClients.append(
			ProductOnClient(
				clientId       = 'hostname.domain.tld',
				productId      = product.id,
				productType    = product.getType(),
				productVersion = product.productVersion,
				packageVersion = product.packageVersion,
				actionRequest  = 'setup'
			)
		)
		productDependencies.extend(productsDependenciesByIdAndVersion.get(productOnDepot.productId, {}).get(productOnDepot.productVersion, {}).get(productOnDepot.packageVersion, []))

	productIds.sort()
	cacheKey = sortAlgorithm + ';' + u';'.join(productIds)
	if cacheKey:
		if productOrderingCache.has_key(cacheKey):
			return {
				"not_sorted": productIds,
				"sorted":     productOrderingCache[cacheKey]
			}
	sortedList = []
	if (sortAlgorithm == "algorithm1"):
		for productOnClient in OPSI.SharedAlgorithm.generateProductOnClientSequence_algorithm1(productOnClients, availableProducts, productDependencies):
			sortedList.append(productOnClient.productId)
	else:
		for productOnClient in OPSI.SharedAlgorithm.generateProductOnClientSequence_algorithm2(productOnClients, availableProducts, productDependencies):
			sortedList.append(productOnClient.productId)
	if sortedList and cacheKey:
		productOrderingCache[cacheKey] = sortedList
	return {
		"not_sorted": productIds,
		"sorted":     sortedList
	}
