# -*- coding: utf-8 -*-

def SSHCommand_getObjects(self):
	return self.getSSHCommands()
def SSHCommand_getObject(self, menuText):
	return self.getSSHCommand(menuText)

def getSSHCommands(self, create_new_file=False):
	import json
	if create_new_file:
		return self._createNewSSHCommandFile()
	filecontent=[]
	with open(self._getSSHCommandFilename(), 'r') as f:
		try:
			for line in f:
				filecontent.append(json.loads(line))
		except ValueError as ve:
			print( u' ValueError can not load file')
			print(ve)
			self._getSSHCommandFile()
	assert isinstance(filecontent, list), u'json file content ({}) should be from type list '.format(self._getSSHCommandFilename())
	for element in filecontent:
		assert isinstance(element, dict), u'expected elements(single commands) of type dictionary'
	return filecontent

def getSSHCommand(self, menuText):
	existingCommands=self.getSSHCommands()
	for command in existingCommands:
		if command["menuText"]==menuText:
			return command
	return None


def SSHCommand_createObjects(self, command_list):
	return self.createSSHCommands(command_list)
def SSHCommand_createObject(self,menuText,commands,position=0,needSudo=False,tooltipText=u'',parentMenuText=None ):
	return self.createSSHCommand(menuText, commands, position, needSudo ,tooltipText, parentMenuText )

def createSSHCommands(self, command_list):
	#assert isinstance(command_list, list), u'method parameter "command_list" should be from type list'
	self._checkCommand_list(command_list)
	for com in command_list:
		self._writeSSHCommand(com)
	return self.getSSHCommands()

def createSSHCommand(self,menuText,commands,position=0, needSudo=False ,tooltipText=u'', parentMenuText=None ):
	com=self._getSSHCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	return self._writeSSHCommand(com)



def SSHCommand_updateObjects(self, command_list):
	return self.updateSSHCommands(command_list)
def SSHCommand_updateObject(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	return self.updateSSHCommand(menuText,commands, position, needSudo, tooltipText, parentMenuText)

def updateSSHCommand(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	existingCommands=self.getSSHCommands()
	com=self._getSSHCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	return self._writeSSHCommand(com,True)

def updateSSHCommands(self, command_list):
	#assert isinstance(command_list, list), u'command_list should be from type list'
	self._checkCommand_list(command_list)
	for com in command_list:
		self._writeSSHCommand(com, True)
	return self.getSSHCommands()


def SSHCommand_deleteObjects(self, menuText_list):
	return self.deleteSSHCommands(menuText_list)
def SSHCommand_deleteObject(self, menuText):
	return self.deleteSSHCommand(menuText)

def deleteSSHCommands(self, menuText_list):
	self._checkString_list(menuText_list, u'menuText_list')
	for menuText in menuText_list:
		self.deleteSSHCommand( menuText)
	return self.getSSHCommands()

def deleteSSHCommand(self, menuText):
	assert isinstance(menuText, unicode) , u'menuText should be from type unicode'
	existingCommands=self.getSSHCommands()
	found=False
	for command in existingCommands:
		if command["menuText"]==menuText:
			found=True
			existingCommands.remove(command)
			self._writeSSHCommandFileWith(existingCommands)
	if not found:
		raise Exception(u'Command does not exists')
	return self.getSSHCommands()

def _writeSSHCommand(self, command, overwrite=False):
	existingCommands=self.getSSHCommands()
	exists=False
	if len(existingCommands) > 0:
		for existingCommand in existingCommands:
			if command["menuText"] == existingCommand["menuText"]:
				exists=True
				if overwrite:
					for key, value in command.items():
						if value:
							existingCommand[key]= value
					self._writeSSHCommandFileWith(existingCommands)
	if exists and not overwrite:
		raise Exception(u'Command already exists')
	elif not exists:
		command = self._getFullSSHCommandDict(command)
		existingCommands.append(command)
		self._writeSSHCommandFileWith(existingCommands)
	return self.getSSHCommands()

def _getSSHCommandDict(self,  menuText, commands, position=0, needSudo=False ,tooltipText=u'', parentMenuText=None ):
	assert isinstance(menuText, unicode), u'menuText should be unicode'
	assert isinstance(commands, list), u'commands should be from type list'
	if position is not None:
		assert isinstance(position, int), u'position should be from type int'
	if needSudo is not None:
		assert isinstance(needSudo, bool), u'needSudo should be from type bool'
	assert isinstance(tooltipText, unicode), u'tooltipText should be unicode'
	if parentMenuText is not None:
		assert isinstance(parentMenuText, unicode), u'parentMenuText should be unicode'
	comDict={"id":self._generateId(menuText), "menuText":menuText, "commands":commands, "position":position, "needSudo":needSudo, "tooltipText":tooltipText, "parentMenuText":parentMenuText }
	return comDict

def _getFullSSHCommandDict(self, command):
	if "menuText" not in command:
		raise Exception(u'menuText missing. ')
	if "commands" not in command:
		raise Exception(u'commands missing.')
	if "position" not in command:
		command["position"]=0
	if "needSudo" not in command:
		command["needSudo"]=False
	if "tooltipText" not in command:
		command["tooltipText"]=""
	if "parentMenuText" not in command:
		command["parentMenuText"]=None
	if "id" not in command:
		command["id"] = self._generateId(command["menuText"])
	return command


def _checkCommand_list(self, command_list):
	assert isinstance(command_list, list), u'method parameter "command_list" should be from type list'
	foundElements=False
	for com in command_list:
		assert isinstance(com, dict), u'expected elements(single commands) of type dictionary'
		if not com["menuText"]:
			raise Exception(u'key menuText missing. SSHCommands have not be saved.')
		assert isinstance(com["menuText"], unicode) , u'menuText should be from type unicode'

		if not com["commands"]:
			raise Exception(u'key commands missing.')
		self._checkString_list(com["commands"], u'value of commands')
		#print(com["position"])
		if "position" in com:
			print(com["position"])
			assert isinstance(com["position"], int), u'position should be a number (no decimal)'
		if "needSudo" in com:
			assert isinstance(com["needSudo"], bool), u'needSudo should be a boolean (True/False)'
		if "tooltipText" in com:
			if len(com["tooltipText"]) > 0:
				assert isinstance(com["tooltipText"], unicode), u'tooltipText should be unicode'
		if "parentMenuText" in com:
			if com["parentMenuText"] is not None:
				if len(com["parentMenuText"]) > 0:
					assert isinstance(com["parentMenuText"], unicode), u'parentMenuText should be unicode'
		foundElements=True
	if not foundElements:
		raise Exception("No elements given.")

def _checkString_list(self, liste, listname):
	assert isinstance(liste, list), u'{0} should be from type list'.format(listname)
	foundElements=False
	for element in liste:
		assert isinstance(element, unicode), 'elements have to be unicode'
		foundElements=True
	if not foundElements:
		raise Exception("No elements given")

def _generateId(self, menuText):
	return menuText.lower().replace(" ", "_")

def _getSSHCommandFile(self):
	import os.path
	if not os.path.isfile(self._getSSHCommandFilename()):
		self._createNewSSHCommandFile()
	return self._getSSHCommandFilename()

def _writeSSHCommandFileWith(self, content, mode='w'):
	import json
	with open(self._getSSHCommandFilename(), mode) as f:
		try:
			for element in content:
				json.dump(element, f)
				f.write('\n')
		except Exception as e:
			print(e)

def _createNewSSHCommandFile(self):
	command1= {"id":"rechte_setzen", "menuText":"Rechte setzen", "commands":["opsi-set-rights"], "position":30,"needSudo":True, "tooltipText":"Rechte mittels opsi-set-rights setzen", "parentMenuText":"opsi" }
	command2= {"id":"konfiguration_initalisieren", "menuText":"Konfiguration initalisieren", "commands":["opsi-setup --init-current-config"], "position":40, "needSudo":True, "tooltipText":"Konfiguration initialisieren", "parentMenuText":"opsi" }

	command5={"id":"produkte_aktualisieren", "menuText":"Produkte aktualisieren", "commands":["opsi-productupdater -i -vv"], "position":50, "needSudo":True, "tooltipText":"Standard opsi-Produkte aktualisieren", "parentMenuText":"opsi" }

	command3={"id":"opsiconfd_neustarten","menuText":"opsiconfd neustarten","commands":["service opsiconfd restart"],"position":60, "needSudo":True, "tooltipText":"opsiconfd-Service neustarten", "parentMenuText":"opsi" }
	command4={"id":"opsipxeconfd_neustarten", "menuText":"opsipxeconfd neustarten", "commands":["service opsipxeconfd restart"], "position":70, "needSudo":True, "tooltipText":"opsipxeconfd-Service neustarten", "parentMenuText":"opsi" }

	command_list=[]
	command_list.append(command1)
	command_list.append(command2)
	command_list.append(command5)
	command_list.append(command3)
	command_list.append(command4)
	self._writeSSHCommandFileWith(command_list)
	return self.getSSHCommands()

def _getSSHCommandFilename(self):
	return u'/etc/opsi/server_commands.conf'