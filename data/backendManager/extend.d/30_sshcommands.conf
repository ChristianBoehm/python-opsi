# -*- coding: utf-8 -*-

def _getSSHCommandFilenames(self):
	return [self._getSSHCommandDefaultFilename(), self._getSSHCommandCustomFilename()]

def _getSSHCommandDefaultFilename(self):
	return forceUnicode(u'/etc/opsi/server_commands_default.conf')

def _getSSHCommandCustomFilename(self):
	return forceUnicode(u'/var/lib/opsi/config/server_commands_custom.conf')

def SSHCommand_getObject(self, menuText):
	return self.getSSHCommand(menuText)

def getSSHCommand(self, menuText):
	existingCommands = self.getSSHCommands()
	menuText = forceUnicode(menuText)
	for command in existingCommands:
		if command["menuText"] == menuText:
			return command
	return None

def _isBuiltIn(self, index):
	return index == 0

def SSHCommand_getObjects(self):
	return self.getSSHCommands()

def getSSHCommands(self):
	def readFilecontent(filename, buildIn=False):
		import os
		try:
			if os.path.getsize(filename) <= 0:
				logger.notice(u'file is empty return \{\}')
				return {}

			filecontent = {}
			with open(filename, 'r') as f:
				for line in f:
					logger.debug2(u'line: {0}'.format(line))
					newElement = json.loads(line)
					logger.debug2(u'new element {0}'.format(newElement))
					try:
						filecontent[newElement["id"]] = newElement
						if buildIn:
							filecontent[newElement["id"]]["buildIn"] = True
						self._forceCommandDict(newElement)
					except KeyError:
						logger.error(u'id not exists. pass')
						pass
					logger.debug2(u'{0}'.format(filecontent))

			return filecontent
		except ValueError as ve:
			logger.notice( u' ValueError can not load file {0}'.format(filename))
			logger.logException(u'ValueError {0}'.format(ve))
		except Exception as e:
			logger.notice( u' Exception with file {0}'.format(filename))
			logger.logException(u' {0}'.format(e))

	import json
	all_commands={}
	for index, name in enumerate(self._getSSHCommandFilenames()):
		logger.info("filename: %s " % str(name))
		commands = readFilecontent(str(name), self._isBuiltIn(index))
		if commands is not None:
			if len(commands) is not 0:
				all_commands.update(commands)
	for key,value in all_commands.items():
		forceUnicode(key)
		forceDict(value)
	return list(all_commands.values())

def SSHCommand_createObjects(self, command_list):
	return self.createSSHCommands(command_list)

def createSSHCommands(self, command_list):
	forceList(command_list)
	for c in command_list:
		self._forceCommandDict(c)
		c = self._getCommandDictWithDefaults(c)
		c = self._setDefaults(c)
		self._forceCommandDict(c)
	for com in command_list:
		self._writeSSHCommand(com)
	return self.getSSHCommands()

def _generateId(self, menuText):
	if not menuText:
		raise Exception(u'menuText missing')
	return menuText.lower().replace(" ", "_")

def SSHCommand_createObject(self,menuText,commands=[],position=0,needSudo=False,tooltipText=u'',parentMenuText=None ):
	return self.createSSHCommand(menuText, commands, position, needSudo ,tooltipText, parentMenuText )

def createSSHCommand(self,menuText,commands=[u''],position=0, needSudo=False ,tooltipText=u'', parentMenuText=None ):
	com=self._createCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	logger.notice(u'command:')
	logger.notice(com)
	self._forceCommandDict(com)
	self._writeSSHCommand(com)
	return self.getSSHCommands()

def SSHCommand_updateObject(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	return self.updateSSHCommand(menuText,commands, position, needSudo, tooltipText, parentMenuText)

def updateSSHCommand(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	com=self._createCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	self._forceCommandDict(com)
	self._writeSSHCommand(com,True)
	return self.getSSHCommands()

def SSHCommand_updateObjects(self, command_list):
	return self.updateSSHCommands(command_list)

def updateSSHCommands(self, command_list):
	forceList(command_list)
	if len(command_list) < 1:
		raise Exception(u'command_list needs at least 1 command')
	for com in command_list:
		logger.notice(u'force commands in commandlist ')
		self._forceCommandDict(com)
	for com in command_list:
		self._writeSSHCommand(com, True)
	return self.getSSHCommands()

def SSHCommand_deleteObjects(self, menuText_list):
	return self.deleteSSHCommands(menuText_list)
def SSHCommand_deleteObject(self, menuText):
	return self.deleteSSHCommand(menuText)

def deleteSSHCommands(self, menuText_list):
	forceUnicodeList(menuText_list)
	if len(menuText_list) < 1:
		raise Exception(u'menuText_list needs at least 1 menuText')
	for menuText in menuText_list:
		self.deleteSSHCommand( menuText)
	return self.getSSHCommands()

def deleteSSHCommand(self, menuText):
	logger.info(u'deleteSSHCommand \"{0}\"'.format(menuText))
	forceUnicode(menuText)
	existingCommands=self.getSSHCommands()
	logger.debug(u'deleteSSHCommand existingCommands\"{0}\"'.format(existingCommands))
	found=False
	indexDel = 0

	my_item = next((item for item in existingCommands if item["menuText"] == menuText), None)
	if my_item is not None:
		found = True
		if not my_item.get("buildIn", False):
			logger.info(u'deleteSSHCommand \"{0}\"'.format(menuText))
			indexDel = existingCommands.index(my_item)

	if not found:
		raise Exception(u'Command does not exists')
	else:
		del existingCommands[indexDel]
		logger.debug(u'deleteSSHCommand new existingCommands\"{0}\"'.format(existingCommands))
		self._writeSSHCommandFileWith(existingCommands)
	return self.getSSHCommands()

def _setDefaults(self, command):
	forceDict(command)
	if not command.get("menuText", False):
		raise Exception(u'menuText missing')
	if not command.get("needSudo", False):
		command["needSudo"] = False
	if command["needSudo"] is None:
		command["needSudo"] = False
	logger.debug(u'command[needSudo] {0}'.format(command["needSudo"]))
	if not command.get("position", False):
		command["position"] = 0
	if command["position"] is None:
		command["position"] = 0
	logger.debug(u'command[position] {0}'.format(command["position"]))
	if not command.get("tooltipText", False):
		command["tooltipText"] = u''
	if command["tooltipText"] is None:
		command["tooltipText"] = u''
	logger.debug(u'command[tooltipText] {0}'.format(command["tooltipText"]))
	if not command.get("parentMenuText", False):
		command["parentMenuText"] = None
	logger.debug(u'command[parentMenuText] {0}'.format(command["parentMenuText"]))
	if not command.get("id", False):
		command["id"] = self._generateId(command.get("menuText"))
	logger.debug(u'command[id] {0}'.format(command["id"]))
	return command

def _getCommandDictWithDefaults(self, command):
	forceDict(command)
	command["needSudo"] = command.get("needSudo", False)
	command["position"] = command.get("position", 0)
	command["tooltipText"] = command.get("tooltipText", u'')
	command["parentMenuText"] = command.get("parentMenuText", None)
	command["id"] = command.get("id", self._generateId(command["menuText"]))
	return command

def _createCommandDict(self, menuText, commands, position, needSudo ,tooltipText, parentMenuText ):
	command = {}
	if menuText is None:
		raise Exception(u'menuText cannot be None')
	command["menuText"] = forceUnicode(menuText)
	if commands is None:
		raise Exception(u'commands cannot be None')
	command["commands"]=forceUnicodeList(commands)
	if needSudo:
		command["needSudo"] = forceBool(needSudo)
	if position:
		command["position"] = forceInt(position)
	command["tooltipText"] = forceUnicode(tooltipText or '')
	command["parentMenuText"] = parentMenuText
	command["id"] = self._generateId(command["menuText"])
	return command

def _forceCommandDict(self, c):
	logger.debug2(u'force command dict  {0}'.format(c))
	forceUnicode(c["menuText"])
	if c.get("id", False):
		if c["id"] is not None:
			forceUnicode(c["id"])
	if c.get("commands", False):
		forceUnicodeList(c["commands"])
		if len(c["commands"]) < 1:
			raise Exception(u'"commands" needs at least 1 command')
	else:
		raise Exception(u'"commands" needs at least 1 command')

	if c.get("position", False):
		assert isinstance(c["position"], int), u'position should be from type int'
		forceInt(c["position"])
	if c.get("needSudo", False):
		assert isinstance(c["needSudo"], bool), u'needSudo should be from type bool'
		forceBool(c["needSudo"])
	if c.get("tooltipText", False):
		forceUnicode(c["tooltipText"])
	if c.get("tooltipText", False):
		if c["parentMenuText"] is not None:
			forceUnicode(c["parentMenuText"])
	logger.debug2(u'forced command dict  {0}'.format(c))

def _writeSSHCommand(self, command, overwrite=False, mode="w"):
	def createCommandDict(c):
		forceDict(c)
		c = self._setDefaults(c)
		self._forceCommandDict(c)
		return c
	existingCommands=self.getSSHCommands()
	exists=False
	logger.info(u'_writeSSHCommand overwrite={0} command={1}'.format(overwrite, command))
	if len(existingCommands) > 0:
		for existingCommand in existingCommands:
			if command["menuText"] == existingCommand["menuText"]:
				logger.notice(u'found command with same menuText ')
				logger.notice(u'old command: {0}'.format(existingCommand))
				logger.notice(u'new command: {0}'.format(command))
				exists=True
				if overwrite:
					for key, value in command.items():
						logger.notice(u'parsing newCommand: {0}:{1}'.format(key,value))
						if value or  value is not  "None":
							if existingCommand[key] == value:
								logger.notice(u'Not Overwrite key {0} ({1}) == {2}'.format(key, existingCommand[key], value))
							else:
								logger.notice(u'Overwrite key {0} ({1}) with {2}'.format(key, existingCommand[key], value))
								existingCommand[key]=value
								if existingCommand.get("buildIn"):
									del existingCommand["buildIn"]
	if exists and not overwrite:
		raise Exception(u'Command already exists')
	elif not exists:
		try:
			logger.notice(u'command does not exists. try to create')
			logger.debug(u'command {0}'.format(command))
			newCom = createCommandDict(command)
			logger.debug(u'creating command: {0}'.format(newCom))
			existingCommands.append(newCom)
		except Exception as e:
			logger.logException(u'error while creating new command: {0}'.format(e))
	self._writeSSHCommandFileWith(existingCommands)

def _writeSSHCommandFileWith(self, content, mode='w'):
	import json
	with open(self._getSSHCommandCustomFilename(), mode) as f:
		try:
			for element in content:
				if element:
					if not element.get("buildIn", False):
						json.dump(element, f)
						f.write('\n')
		except Exception as e:
			logger.notice(u'error while writing content: {0}'.format(content))
			logger.logException(u'error: {0}'.format(e))
