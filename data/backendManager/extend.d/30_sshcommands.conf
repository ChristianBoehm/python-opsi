# -*- coding: utf-8 -*-

def _getSSHCommandFilenames(self):
	return [self._getSSHCommandDefaultFilename(), self._getSSHCommandCustomFilename()]
	# return [self._getSSHCommandCustomFilename()]

def _getSSHCommandDefaultFilename(self):
	return  forceUnicode(u'/etc/opsi/server_commands_default.conf')

def _getSSHCommandCustomFilename(self):
	return  forceUnicode(u'/var/lib/opsi/config/server_commands_custom.conf')
	
def SSHCommand_getObject(self, menuText):
	return self.getSSHCommand(menuText)

def getSSHCommand(self, menuText):
	existingCommands=self.getSSHCommands()
	forceUnicode(menuText)
	for command in existingCommands:
		if command["menuText"]==menuText:
			return command
	return None

def _isBuildIn(self, index):
	return index == 0
	

def SSHCommand_getObjects(self):
	return self.getSSHCommands()

def getSSHCommands(self):
	def readFilecontent(filename, buildIn=False):
		import os
		try:
			with open(filename, 'r') as f:
				filecontent={}
				# if not f.read(3):
				if os.path.getsize(filename) <=0:
					logger.notice(u'file is empty return \{\}')
					return filecontent
				else:
					for line in f:
						logger.debug2(u'line: {0}'.format(line))
						newElement = json.loads(line)
						logger.debug2(u'new element {0}'.format(newElement))
						try:
							filecontent[newElement["id"]] = newElement
							if buildIn:
								filecontent[newElement["id"]]["buildIn"] = True
							self._forceCommandDict(newElement)
						except KeyError:
							logger.error(u'id not exists. pass')
							pass
					logger.debug2(u'{0}'.format(filecontent))
					return filecontent
		except ValueError as ve:
			logger.notice( u' ValueError can not load file {0}'.format(filename))
			logger.logException(u'ValueError {0}'.format(ve))
		except Exception as e:
			logger.notice( u' Exception with file {0}'.format(filename))
			logger.logException(u' {0}'.format(e))
	import json
	all_commands={}
	for index, name in enumerate(self._getSSHCommandFilenames()):
		logger.info("filename: %s " % str(name))
		commands = readFilecontent(str(name), self._isBuildIn(index))
		if commands is not None:
			if len(commands) is not 0:
				all_commands.update(commands)
	for key,value in all_commands.items():
		forceUnicode(key)
		forceDict(value)
	return list(all_commands.values())

def SSHCommand_createObjects(self, command_list):
	return self.createSSHCommands(command_list)

def createSSHCommands(self, command_list):
	forceList(command_list)
	for c in command_list:
		self._forceCommandDict(c)
		c = self._getCommandDictWithDefaults(c)
		c = self._setDefaults(c)
		self._forceCommandDict(c)
	for com in command_list:
		self._writeSSHCommand(com)
	return self.getSSHCommands()

def _generateId(self, menuText):
	if not menuText:
		raise Exception(u'menuText missing')
	return menuText.lower().replace(" ", "_")

def SSHCommand_createObject(self,menuText,commands=[],position=0,needSudo=False,tooltipText=u'',parentMenuText=None ):
	return self.createSSHCommand(menuText, commands, position, needSudo ,tooltipText, parentMenuText )

def createSSHCommand(self,menuText,commands=[u''],position=0, needSudo=False ,tooltipText=u'', parentMenuText=None ):
	com=self._createCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	logger.notice(u'>>>>>>>>>>>>>>>>>>> command:')
	logger.notice(com)
	self._forceCommandDict(com)
	return self._writeSSHCommand(com)

def SSHCommand_updateObject(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	return self.updateSSHCommand(menuText,commands, position, needSudo, tooltipText, parentMenuText)

def updateSSHCommand(self, menuText, commands=None, position=None, needSudo=None ,tooltipText=None, parentMenuText=None ):
	# existingCommands=self.getSSHCommands()
	com=self._createCommandDict( menuText, commands, position, needSudo, tooltipText, parentMenuText)
	self._forceCommandDict(com)
	return self._writeSSHCommand(com,True)

def SSHCommand_updateObjects(self, command_list):
	return self.updateSSHCommands(command_list)

def updateSSHCommands(self, command_list):
	#assert isinstance(command_list, list), u'command_list should be from type list'
	# self._checkCommand_list(command_list)
	forceList(command_list)
	if len(command_list) < 1:
		raise Exception(u'command_list needs at least 1 command')
	for com in command_list:
		logger.notice(u'force commands in commandlist ')
		self._forceCommandDict(com)
	for com in command_list:
		self._writeSSHCommand(com, True)
	return self.getSSHCommands()

def SSHCommand_deleteObjects(self, menuText_list):
	return self.deleteSSHCommands(menuText_list)
def SSHCommand_deleteObject(self, menuText):
	return self.deleteSSHCommand(menuText)

def deleteSSHCommands(self, menuText_list):
	forceUnicodeList(menuText_list)
	if len(menuText_list) < 1:
		raise Exception(u'menuText_list needs at least 1 menuText')
	for menuText in menuText_list:
		self.deleteSSHCommand( menuText)
	return self.getSSHCommands()

def deleteSSHCommand(self, menuText):
	logger.info(u'deleteSSHCommand \"{0}\"'.format(menuText))
	forceUnicode(menuText)
	existingCommands=self.getSSHCommands()
	logger.debug(u'deleteSSHCommand existingCommands\"{0}\"'.format(existingCommands))
	found=False
	indexDel = 0
	# commandToDelete = {}
	for command in existingCommands:
		logger.info(u'if command["menuText"]==menuText \"{0}\"'.format(command["menuText"]==menuText))
		if command["menuText"]==menuText:
			found=True
			logger.info(u'deleteSSHCommand \"{0}\"'.format(menuText))
			if command.get("buildIn", False):
				logger.info(u'found command  \"{0}\"'.format(command))
				# existingCommands.remove(command)
				# del existingCommands[command]
				# commandToDelete = command
				indexDel = existingCommands.index(command)
				# del existingCommands[existingCommands.index(command)]
	if not found:
		raise Exception(u'Command does not exists')
	else:
		# del existingCommands[existingCommands.index(commandToDelete)]
		del existingCommands[indexDel]
		logger.debug(u'deleteSSHCommand new existingCommands\"{0}\"'.format(existingCommands))
		self._writeSSHCommandFileWith(existingCommands)
	return self.getSSHCommands()



def _setDefaults(self, command):
	forceDict(command)
	if command.get("needSudo", None):
		command["needSudo"] = False
	if command["needSudo"] is None:
		command["needSudo"] = False
	logger.debug(u'command[needSudo] {0}'.format(command["needSudo"]))
	if command.get("position", None):
		command["position"] = 0
	if command["position"] is None:
		command["position"] = 0
	logger.debug(u'command[position] {0}'.format(command["position"]))
	if command.get("tooltipText", None):
		command["tooltipText"] = u''
	if command["tooltipText"] is None:
		command["tooltipText"] = u''
	logger.debug(u'command[tooltipText] {0}'.format(command["tooltipText"]))
	return command

def _getCommandDictWithDefaults(self, command):
	forceDict(command)
	command["needSudo"] = command.get("needSudo", False)
	command["position"] = command.get("position", 0)
	command["tooltipText"] = command.get("tooltipText", u'')
	command["parentMenuText"] = command.get("parentMenuText", None)
	command["id"] = command.get("id", self._generateId(command["menuText"]))
	return command

def _createCommandDict(self, menuText, commands, position, needSudo ,tooltipText, parentMenuText ):
	command = {}
	if menuText is None: 
		raise Exception(u'menuText cannot be None')
	command["menuText"] = forceUnicode(menuText)
	if commands is None:
		raise Exception(u'commands cannot be None')
	command["commands"]=forceUnicodeList(commands)
	command["needSudo"] = forceBool(needSudo)
	command["position"] = forceInt(position)
	command["tooltipText"] = forceUnicode(tooltipText)
	command["parentMenuText"] = parentMenuText
	command["id"] = self._generateId(command["menuText"])
	return command

def _forceCommandDict(self, c):
	logger.debug2(u'force command dict  {0}'.format(c))
	forceUnicode(c["menuText"])
	forceUnicode(c["id"])
	forceUnicodeList(c["commands"])
	if len(c["commands"]) < 1:
		raise Exception(u'commandlist needs at least 1 command')
	forceInt(c["position"])
	forceBool(c["needSudo"])
	forceUnicode(c["tooltipText"])
	if c["parentMenuText"] is not None:
		forceUnicode(c["parentMenuText"])

def _writeSSHCommand(self, command, overwrite=False, mode="w"):
	def createCommandDict(c):
		forceDict(c)
		# c = self._getCommandDictWithDefaults(c)
		c = self._setDefaults(c)
		self._forceCommandDict(c)
		return c
	existingCommands=self.getSSHCommands()
	exists=False
	logger.info(u'_writeSSHCommand overwrite={0} command={1}'.format(overwrite, command))
	if len(existingCommands) > 0:
		for existingCommand in existingCommands:
			if command["menuText"] == existingCommand["menuText"]:
				logger.notice(u'found command with same menuText ')
				logger.notice(u'old command: {0}'.format(existingCommand))
				exists=True
				if overwrite:
					for key, value in command.items():
						if value: 
							if value is not  "None":
								if existingCommand[key] == value:
									logger.notice(u'Not Overwrite key {0} ({1}) == {2}'.format(key, existingCommand[key], value))
								else:

									logger.notice(u'Overwrite key {0} ({1}) with {2}'.format(key, existingCommand[key], value))
									existingCommand[key]=value
									if existingCommand.get("buildIn"):
										del existingCommand["buildIn"]
					# self._writeSSHCommandFileWith(existingCommands)
	if exists and not overwrite:
		raise Exception(u'Command already exists')
	elif not exists:
		try:
			logger.notice(u'command does not exists. try to create')
			logger.debug(u'command {0}'.format(command))
			logger.debug(u'creating command: {0}'.format(createCommandDict(command)))
			existingCommands.append(createCommandDict(command))
		except Exception as e:
			logger.logException(u'error while creating new command: {0}'.format(e))
	self._writeSSHCommandFileWith(existingCommands)
	return self.getSSHCommands()

def _writeSSHCommandFileWith(self, content, mode='w'):
	import json
	with open(self._getSSHCommandCustomFilename(), mode) as f:
		try:
			for element in content:
				if element:
					if not element.get("buildIn", False):
						json.dump(element, f)
						f.write('\n')
		except Exception as e:
			logger.notice(u'error while writing content: {0}'.format(content))
			logger.logException(u'error: {0}'.format(e))
